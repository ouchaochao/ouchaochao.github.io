<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ouchaochao.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 19 Sep 2019 20:29:34 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java Introduction</title>
      <link>https://ouchaochao.github.io/post/java_introduction/</link>
      <pubDate>Thu, 19 Sep 2019 20:29:34 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/java_introduction/</guid>
      <description>

&lt;p&gt;慕课链接&lt;/p&gt;

&lt;h2 id=&#34;基础概念&#34;&gt;基础概念&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;JavaSE：基础核心；面向对象、API、JVM、
JavaME：移动设备、游戏、通信
JavaEE：JSP、EJB、服务
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;JVM：Java Virtual Machine 
JRE：Java Development Kit Java开发工具包
JDK：Java Runtime Environment Java运行时环境

JRE = JVM + JavaSE标准类库
JDK = JRE + 开发工具集（如：Javac编译工具等） 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 环境变量
JAVA_HOME：配置JDK安装路径 （JDK）
PATH：配置JDK命令文件的位置（JDK/bin）
CLASSPATH：配置类库文件的位置（JDK/lib）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;javac XXX.java：编译文件，生成XXX.class
java XXX：解释器；运行文件（不用带.class后缀！）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第一个程序&#34;&gt;第一个程序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package helloworld;

public class helloworld {
    public static void main(String[] args){
        System.out.println(&amp;quot;Hello world&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;认识java标识符&#34;&gt;认识Java标识符&lt;/h2&gt;

&lt;p&gt;标识符就是用于给 Java 程序中变量、类、方法等命名的符号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/blog/%E6%A0%87%E8%AF%86%E7%AC%A6.jpg&#34; alt=&#34;标识符&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用标识符时，需要遵守几条规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;标识符&lt;strong&gt;可以&lt;/strong&gt;由&lt;strong&gt;字母、数字、下划线（_）、美元符（$）&lt;/strong&gt;组成，但不能包含 @、%、空格等其它特殊字符&lt;strong&gt;，不能以数字开头&lt;/strong&gt;。譬如：123name 就是不合法滴&lt;/li&gt;
&lt;li&gt;标识符&lt;strong&gt;不能是 Java 关键字和保留字&lt;/strong&gt;（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以&lt;/li&gt;
&lt;li&gt;标识符是&lt;strong&gt;严格区分大小写&lt;/strong&gt;的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！&lt;/li&gt;
&lt;li&gt;标识符的命名最好能反映出其作用，做到&lt;strong&gt;见名知意&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何命名java变量&#34;&gt;如何命名Java变量&lt;/h2&gt;

&lt;p&gt;优秀攻城师的习惯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;变量名由多单词组成时，&lt;strong&gt;第一个单词的首字母小写&lt;/strong&gt;，&lt;strong&gt;其后单词的首字母大写&lt;/strong&gt;，俗称骆驼式命名法（也称驼峰命名法），如 myAge&lt;/li&gt;
&lt;li&gt;变量命名时，尽量简短且能清楚的表达变量的作用，做到&lt;strong&gt;见名知意&lt;/strong&gt;。如：定义变量名 stuName 保存“学生姓名”信息&lt;/li&gt;
&lt;li&gt;PS： Java 变量名的&lt;strong&gt;长度没有限制&lt;/strong&gt;，但 Java 语言&lt;strong&gt;是区分大小写&lt;/strong&gt;的，所以 price 和 Price 是两个完全不同的变量哦！&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;java中的数据类型&#34;&gt;Java中的数据类型&lt;/h2&gt;

&lt;p&gt;Java 语言是一种&lt;strong&gt;强类型&lt;/strong&gt;语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/blog/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 Java 的领域里&lt;strong&gt;，基本数据类型变量&lt;/strong&gt;存的是&lt;strong&gt;数据本身&lt;/strong&gt;，而&lt;strong&gt;引用类型变量&lt;/strong&gt;存的是保存&lt;strong&gt;数据的空间地址&lt;/strong&gt;。说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。&lt;/p&gt;

&lt;p&gt;常用的基本数据类型有：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/blog/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/blog/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注：关于 float 型和 double 型的区别，以及 char 型和 String 型的不同，在 wiki 中有相关的总结，小伙伴们可以去查看哦~~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt; 是一种常见的&lt;strong&gt;引用数据类型&lt;/strong&gt;，用来表示字符串。在程序开发中，很多操作都要使用字符串来完成，例如系统中的用户名、密码、电子邮箱等。&lt;/p&gt;

&lt;h2 id=&#34;java常量的应用&#34;&gt;Java常量的应用&lt;/h2&gt;

&lt;p&gt;所谓常量，我们可以理解为是一种特殊的变量，它的值被设定后，在&lt;strong&gt;程序运行过程中不允许改变&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;语法：&lt;strong&gt;final 常量名 = 值;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/blog/final.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;程序中使用常量可以提高代码的&lt;strong&gt;可维护性&lt;/strong&gt;。例如，在项目开发时，我们需要指定用户的性别，此时可以定义一个常量 SEX，赋值为 &amp;ldquo;男&amp;rdquo;，在需要指定用户性别的地方直接调用此常量即可，避免了由于用户的不规范赋值导致程序出错的情况。&lt;/p&gt;

&lt;p&gt;伙计们注意啦：常量名一般使用&lt;strong&gt;大写字符&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何在java中使用注释&#34;&gt;如何在Java中使用注释&lt;/h2&gt;

&lt;p&gt;Java 中注释有三种类型：&lt;strong&gt;单行注释、多行注释、文档注释&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/blog/notes.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;java中的条件运算符&#34;&gt;Java中的条件运算符&lt;/h2&gt;

&lt;p&gt;条件运算符（ ? : ）也称为 “三元运算符”。&lt;/p&gt;

&lt;p&gt;语法形式：&lt;strong&gt;布尔表达式 ？ 表达式1 ：表达式2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运算过程：如果布尔表达式的值为 &lt;strong&gt;true&lt;/strong&gt; ，则返回 &lt;strong&gt;表达式1&lt;/strong&gt; 的值，否则返回 &lt;strong&gt;表达式2&lt;/strong&gt; 的值&lt;/p&gt;

&lt;h2 id=&#34;如何使用-java-中的数组&#34;&gt;如何使用 Java 中的数组&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1
int[] s = new int[5];

// 2
int[] s = {1, 2, 3, 4, 5};
// equal
int[] s = new int[]{1, 2, 3, 4, 5};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;java-中的二维数组&#34;&gt;Java 中的二维数组&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorld {
    public static void main(String[] args) {
        
		// 定义两行三列的二维数组并赋值
		String[][] names={{&amp;quot;tom&amp;quot;,&amp;quot;jack&amp;quot;,&amp;quot;mike&amp;quot;},{&amp;quot;zhangsan&amp;quot;,&amp;quot;lisi&amp;quot;,&amp;quot;wangwu&amp;quot;}};
                 
		// 通过二重循环输出二维数组中元素的值
    // 定位行
		for (int i = 0; i &amp;lt;   names.length  ; i++) {
      // 定位列      
			for (int j = 0; j &amp;lt; names[i].length; j++) {
                
				System.out.println(names[i][j]);
			}
      
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MySQL Crash Course 1</title>
      <link>https://ouchaochao.github.io/post/mysql/</link>
      <pubDate>Mon, 09 Sep 2019 21:08:49 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/mysql/</guid>
      <description>

&lt;p&gt;以下是看&lt;code&gt;MySQL必知必会&lt;/code&gt;这本书总结的一些知识点，备忘。&lt;/p&gt;

&lt;h2 id=&#34;检索数据&#34;&gt;检索数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 检索单个列
SELECT prod_name FROM products;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 检索多个列
SELECT prod_id, prod_name, prod_price FROM products;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 检索所有列
SELECT * FROM products;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 检索不同行（相同行只会显示一次）
SELECT DISTINCT prod_id FROM products;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 限制结果
SELECT prod_name FROM products LIMIT 5; # 返回5行

SELECT prod_name FROM products LIMIT 5,5; # 返回第五行开始的5行
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;排序检索数据&#34;&gt;排序检索数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 排序数据
SELECT prod_name FROM products ORDER BY prod_name; # 升序（A-Z）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 按多个列排序
SELECT prod_id, prod_name, prod_price FROM products ORDER BY prod_price, prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 指定排序方向
SELECT prod_name FROM products ORDER BY prod_name DESC; # 降序（Z-A）

SELECT prod_id, prod_name, prod_price FROM products ORDER BY prod_price DESC, prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;过滤数据&#34;&gt;过滤数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 使用WHERE子句
SELECT prod_name FROM products WHERE prod_price = 2.5;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;操作符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;!=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;大于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;BETWEEN&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在指定的两个值之间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 使用BETWEEN
SELECT prod_name FROM products WHERE prod_price BETWEEN 2 AND 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 空值检查
SELECT prod_name FROM products WHERE prod_price IS NULL;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数据过滤&#34;&gt;数据过滤&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# AND
SELECT prod_name FROM products WHERE prod_price = 2.5 AND prod_id = 1001;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# OR
SELECT prod_name FROM products WHERE prod_price = 2.5 OR prod_price = 3.0;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 注意计算次序
SELECT prod_name FROM products WHERE (prod_price = 2.5 OR prod_price = 3.0) AND prod_id = 1001;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# IN
SELECT prod_name FROM products WHERE prod_price IN (2.5,3.0) ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# NOT
SELECT prod_name FROM products WHERE prod_price NOT IN (2.5,3.0) ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用通配符进行过滤&#34;&gt;用通配符进行过滤&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# LIKE %
SELECT prod_name FROM products WHERE prod_name LIKE &#39;%jet%&#39;; # %表示任何字符出现任意次数

SELECT prod_name FROM products WHERE prod_name LIKE &#39;j%t&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# _ 匹配单个任意字符
SELECT prod_name FROM products WHERE prod_name LIKE &#39;j_t&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用正则表达式进行搜索&#34;&gt;用正则表达式进行搜索&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# REGEXP MySQL中的正则表达式匹配不区分大小写
SELECT prod_name FROM products WHERE prod_id REGEXP &#39;1001&#39; ORDER BY prod_name;

# BINARY 使得正则表达式区分大小写
SELECT prod_name FROM products WHERE prod_name REGEXP BINARY &#39;AbCd&#39; ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# . 表示匹配任意一个字符
SELECT prod_name FROM products WHERE prod_name REGEXP &#39;.001&#39; ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# OR
SELECT prod_name FROM products WHERE prod_id REGEXP &#39;1001 | 1002&#39; ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 匹配几个字符中之一: []
SELECT prod_name FROM products WHERE prod_id REGEXP &#39;[123]001&#39; ORDER BY prod_name;
# 等价于
SELECT prod_name FROM products WHERE prod_id REGEXP &#39;1|2|3 001&#39; ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 匹配范围
SELECT prod_name FROM products WHERE prod_id REGEXP &#39;[1-9]001&#39; ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 匹配特殊字符加 \\
SELECT prod_name FROM products WHERE prod_name REGEXP &#39;\\.&#39; ORDER BY prod_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;元字符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\\f&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;换页&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\\n&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;换行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\\r&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;回车&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\\t&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;制表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;\\v&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;纵向制表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 匹配字符类（多个实例）
SELECT prod_name FROM products WHERE prod_name REGEXP &#39;\\([0-9]sticks?\\)&#39; ORDER BY prod_name; # ?的存在使得 stick 和 sticks 能同时存在，它匹配0或1个匹配
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;元字符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0或多个匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;+&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1或多个匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;?&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0或1个匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n}&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;指定数目的匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n,}&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不少于指定数目的匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n,m}&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;匹配数目范围[n,m]，m&amp;lt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 匹配字符类
SELECT prod_name FROM products WHERE prod_id REGEXP &#39;[[:digits:]]{4}&#39; ORDER BY prod_name;
# [[:digits:]]{4} 等价于 [0-9][0-9][0-9][0-9]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;字符类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:alnum:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[a-zA-Z0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:alpha:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[a-zA-Z]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:blank:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;空格和制表 [\\t]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:cntrl:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ASCII 控制字符（ASCII 0到31和127）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:digit:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[0-9]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:graph:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;与[:print:]相同，但不包括空格&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:lower:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[a-z]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:print:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;任意可打印字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:punct:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不在[:alnum:]和[:cntrl:]中的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:space:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;包括空格在内的空白字符[\\f\\n\\r\\t\\v]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:upper:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[A-Z]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:xdigit:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;任意16进制数字[a-fA-F0-9]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 定位符
SELECT prod_name FROM products WHERE prod_name REGEXP &#39;^[0-9]&#39; ORDER BY prod_name;
# ^ 表示文本的开始位置进行检索
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;元字符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;^&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;文本的开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;文本的结尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[[:&amp;lt;:]]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;词的开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[[::&amp;gt;]]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;词的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;创建计算字段&#34;&gt;创建计算字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;# 拼接
SELECT Concat(prod_name,&#39;(&#39;, prod_price, &#39;)&#39;) FROM products ORDER BY prod_name

# RTrim 去掉右边的空格， LTrim 去掉左边的空格， Trim去掉两边的空格
SELECT Concat(RTrim(prod_name),&#39;(&#39;, RTrim(prod_price), &#39;)&#39;) 
FROM products ORDER BY prod_name

# 使用别名 AS
SELECT Concat(RTrim(prod_name),&#39;(&#39;, RTrim(prod_price), &#39;)&#39;) 
AS prod_name_price
FROM products ORDER BY prod_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今天就先到这吧~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>富途现场笔试感受</title>
      <link>https://ouchaochao.github.io/post/%E5%AF%8C%E9%80%94%E7%8E%B0%E5%9C%BA%E7%AC%94%E8%AF%95%E6%84%9F%E5%8F%97/</link>
      <pubDate>Fri, 06 Sep 2019 22:47:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/%E5%AF%8C%E9%80%94%E7%8E%B0%E5%9C%BA%E7%AC%94%E8%AF%95%E6%84%9F%E5%8F%97/</guid>
      <description>&lt;p&gt;今晚去了富途的宣讲会，感觉这是一个朝气蓬勃的公司，我自己而言是非常喜欢互联网和金融这两块内容的，所以还是很希望自己能进入这样的公司。&lt;/p&gt;

&lt;p&gt;讲讲现场笔试吧。真的是许久没有手写过笔试题了，很怀念的感觉，一共90分钟，做的是后台的题目，考的内容包括数据结构、计算机网络、操作系统、数据库，题型包括选择题、填空题和编程题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择题&lt;/strong&gt;做的比较顺畅，里面有几道智力题，其中有一道是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;有4个人，ABCD，每个人都头上都带了个帽子，帽子只有黑色或白色，4个人中分别有两个人带黑色，有两个人带白色，4个人的站位是A|B C D,|是一堵墙，B，C，D分别站在平地，一层台阶，二层台阶上，每个人都看不到自己带的帽子，一开始大家都不讲话，突然有个人说，我知道自己带的什么颜色的帽子了，请问是谁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想了很久也没有想出来，觉得可能出错题？于是就填了D，上网看了一下答案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;是C或者D
理由如下：首先考虑C，他看见D和B的帽子，但是他没有推理出自己的颜色（一开始大家都不讲话），所以B和D异色。
同样的由于D也没有推理出自己的颜色，于是C和B异色。
此时，C明白过来，因为D也没有推理出自己的颜色，于是自己和D共色，于是他便说出了D头上帽子的颜色便是自己的颜色。
由于A和B相当于什么都看不见，仅仅凭着别人的推理只能知道共边关系，但是由于没有初始条件，不知道某一帽子的配置，于是无法推知自己帽子的颜色
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它的选择题做的还算顺利。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;填空题&lt;/strong&gt;就有点难受了，忘了MySQL怎么写查询了，略尴尬，问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;查询出每个部门的人员总数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select count(人员id) from 部门人员表 group by 部门编号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一道网络的题目，计算包大小的，包越大丢包率越大，要怎么设计，表示不会。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编程题&lt;/strong&gt;是写计算地铁票该算多少钱的，这道题感觉自己都写对了？emmm，蜜汁自信。&lt;/p&gt;

&lt;p&gt;总的来说，经历了第一次笔试，感觉很良好，同时也发现自己有很多的不足，趁着还有点时间多看看书吧，2333&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_15至3_18</title>
      <link>https://ouchaochao.github.io/post/go3_15to3_16/</link>
      <pubDate>Tue, 20 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_15to3_16/</guid>
      <description>

&lt;h2 id=&#34;聊聊session&#34;&gt;聊聊session&lt;/h2&gt;

&lt;p&gt;在了解session之前先要了解什么是cookie:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么是session？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/go/3_15_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;cookie和session结合使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1、存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Session 创建过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当用户访问Web应用时，服务端程序会随需要创建session，这个过程可以概括为三个步骤：

生成全局唯一标识符（sessionid）；
开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，当然这样会增加 I/O 开销，但是它可以实现某种程度的 session 持久化，也更有利于 session 的共享；
将 session 的全局唯一标示符发送给客户端。
以上三个步骤中，最关键的是如何发送这个 session 的唯一标识这一步上。考虑到 HTTP 协议的定义，数据无非可以放到请求行、头域或 Body 里，所以一般来说会有两种常用的方式： cookie 和 URL 重写。

Cookie 服务端通过设置 Set-cookie 头就可以将 session 的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，另外一般包含 session 信息的 cookie 会将失效时间设置为0(会话 cookie)，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大(一般体现在新建浏览器窗口的时候)；
URL重写， 所谓URL重写，就是在返回给用户的页面里的所有的URL后面追加session标识符，这样用户在收到响应之后，无论点击响应页面里的哪个链接或提交表单，都会自动带上session标识符，从而就实现了会话的保持。虽然这种做法比较麻烦，但是，如果客户端禁用了cookie的话，此种方案将会是首选。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;go中的session&#34;&gt;GO中的session&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;流程
main-&amp;gt;middleware-&amp;gt;defs(message, err)-&amp;gt;handlers-&amp;gt;dbops-&amp;gt;response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;main.go&lt;/code&gt;中添加&lt;code&gt;middleware&lt;/code&gt;，在&lt;code&gt;middleware&lt;/code&gt;中处理校验、健全、流控等：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//main.go
package main

import (
	&amp;quot;github.com/julienschmidt/httprouter&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;video/api/handlers&amp;quot;
)

type middleWareHandler struct {
	r *httprouter.Router
}

func NewMiddleWareHandler(r *httprouter.Router) http.Handler {
	m := middleWareHandler{}
	m.r = r
	return m
}
func (m middleWareHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	//check session
	handlers.ValidateUserSession(r)
	m.r.ServeHTTP(w, r)
}

func RegisterHandlers() *httprouter.Router {
	router := httprouter.New()
	router.POST(&amp;quot;/user&amp;quot;, handlers.CreateUser)
	router.POST(&amp;quot;/user/:username&amp;quot;, handlers.Login)
	return router
}

func main() {
	r := RegisterHandlers()
	mh := NewMiddleWareHandler(r)
	http.ListenAndServe(&amp;quot;:8000&amp;quot;, mh)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;NewMiddleWareHandler&lt;/code&gt;用到duck type。调用过程如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NewMiddleWareHandler&lt;/code&gt;-&amp;gt;&lt;code&gt;middleWareHandler&lt;/code&gt;-&amp;gt;&lt;code&gt;ServeHTTP&lt;/code&gt;-&amp;gt;&lt;code&gt;auth.go&lt;/code&gt;用户合法校验放在这里面，&lt;code&gt;response.go&lt;/code&gt;返回消息-&amp;gt;&lt;code&gt;ops.go&lt;/code&gt;session的产生和验证过期否 -&amp;gt;&lt;code&gt;internal.go&lt;/code&gt;数据库的增删查session&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
auth.go
文件初始化
 */
package handlers

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/session&amp;quot;
)

//X开头的都是自定义的header,加到原生http header调用里面,构成整个健全过程
var HEADER_FIELD_SESSION = &amp;quot;X-Session-Id&amp;quot;
var HEADER_FAILD_UNAME = &amp;quot;X-User-Name&amp;quot;

//检测用户session是否合法，是就返回username
func ValidateUserSession(r *http.Request) bool {
	//get获取sessionId
	sid := r.Header.Get(HEADER_FIELD_SESSION)
	if len(sid) == 0 {
		return false
	}

	//检测过期否?
	uname, ok := session.IsSessionExpired(sid)
	if ok {
		return false
	}

	r.Header.Add(HEADER_FAILD_UNAME, uname)
	return true
}

func ValidateUser(w http.ResponseWriter, r *http.Request) bool {
	uname := r.Header.Get(HEADER_FAILD_UNAME)
	if len(uname) == 0 {
		sendErrorResponse(w, defs.ErrorNotAuthUser)
		return false
	}
	return true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// session ops.go
package session

import (
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;video/api/dbops&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/utils&amp;quot;
)

//sync.Map自己实现了一套线程安全的机制,优化了并发读,写的话要加锁
var sessionMap *sync.Map

func init() {
	sessionMap = &amp;amp;sync.Map{}
}

//从数据库读取sessionId到cache
func LoadSessionsFromDB() {
	r, err := dbops.RetrieveAllSessions()
	if err != nil {
		//不对外返回东西
		return
	}

	//返回值
	r.Range(func(k, v interface{}) bool {
		ss := v.(*defs.SimpleSession)
		sessionMap.Store(k, ss)
		return true
	})
}


func nowInMilli() int64 {
	//UnixNano纳秒级别, &#39;/ 100000&#39;后变成毫秒级别
	return time.Now().UnixNano() / 100000
}
//产生sessionId
func GenerateNewSessionId(un string) string {
	id, _ := utils.NewUUID()
	ct := nowInMilli()
	//过期时间30min(单位:毫秒)
	ttl := ct + 30*60*1000

	ss := &amp;amp;defs.SimpleSession{Username: un, TTL: ttl}
	sessionMap.Store(id, ss)
	dbops.InsertSession(id, ttl, un)
	return id

}

//session过期否?
func IsSessionExpired(sid string) (string, bool) {
	ss, ok := sessionMap.Load(sid)
	if ok {
		ct := nowInMilli()
		if ss.(*defs.SimpleSession).TTL &amp;lt; ct {
			deleteExpieredSession(sid)
			return &amp;quot;&amp;quot;, true
		}
		return ss.(*defs.SimpleSession).Username, false
	}
	return &amp;quot;&amp;quot;, true
}
//删除过期的session
func deleteExpieredSession(sid string) {
	sessionMap.Delete(sid)
	dbops.DeleteSession(sid)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//response.go
package handlers

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
)

func sendErrorResponse(w http.ResponseWriter, errResp defs.ErrResponse) {
	w.WriteHeader(errResp.HttpSC)

	//Marshal:struct序列化成json
	resStr, _ := json.Marshal(&amp;amp;errResp.Error)
	io.WriteString(w, string(resStr))
}

func sendNormalResponse(w http.ResponseWriter, resp string, sc int) {
	w.WriteHeader(sc)
	io.WriteString(w, resp)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//internal.go
/*
和session相关的db操作单独放在这个文件中
 */
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
)

//往DB中插入session
func InsertSession(sid string, ttl int64, uname string) error {
	/*
	strconv是golang用来做数据类型转换的一个库
	FormatInt 将十进制的Int类型转换为String类型
	ParseInt 将字符串转换为值
	最常见的数值转换是 Atoi(string to int)和 Itoa(int to string)
	*/
	ttlstr := strconv.FormatInt(ttl, 10)
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO sessions (session_id, TTL, login_name) VALUES (?, ?, ?)&amp;quot;)
	if err != nil {
		return err
	}

	_, err = stmtIns.Exec(sid, ttlstr, uname)
	if err != nil {
		return err
	}

	defer stmtIns.Close()
	return nil
}

func RetrieveSession(sid string) (*defs.SimpleSession, error) {
	ss := &amp;amp;defs.SimpleSession{}
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT TTL, login_name FROM sessions WHERE session_id=?&amp;quot;)
	if err != nil {
		return nil, err
	}

	var ttl string
	var uname string
	stmtOut.QueryRow(sid).Scan(&amp;amp;ttl, &amp;amp;uname)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return nil, err
	}

	if res, err := strconv.ParseInt(ttl, 10, 64); err == nil {
		ss.TTL = res
		ss.Username = uname
	} else {
		return nil, err
	}
	defer stmtOut.Close()
	return ss, nil
}

//sessions放在map里,一块返回
func RetrieveAllSessions() (*sync.Map, error) {
	m := &amp;amp;sync.Map{}
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT * FROM sessions&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		return nil, err
	}

	rows, err := stmtOut.Query()
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		return nil, err
	}

	for rows.Next() {
		var id string
		var ttlstr string
		var login_name string
		if er := rows.Scan(&amp;amp;id, &amp;amp;ttlstr, &amp;amp;login_name); er != nil {
			log.Printf(&amp;quot;retrive sessions error: %s&amp;quot;, er)
			break
		}
		if ttl, err1 := strconv.ParseInt(ttlstr, 10, 64); err1 == nil {
			ss := &amp;amp;defs.SimpleSession{Username: login_name, TTL: ttl}
			m.Store(id, ss)
			log.Printf(&amp;quot;session id: %s,ttl:%d&amp;quot;, id, ss.TTL)
		}
	}
	return m, nil
}

func DeleteSession(sid string) error {
	stmtOut, err := dbConn.Prepare(&amp;quot;DELETE FROM sessions WHERE session_id=?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		return err
	}

	if _, err := stmtOut.Query(sid); err != nil {
		return err
	}
	return nil

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;至此session部分和middleware部分告一段落，但是关于middleware的这个调用过程还不是很熟悉，需要再加深理解。&lt;/p&gt;

&lt;h2 id=&#34;refers&#34;&gt;Refers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/xxtalhr/p/9053906.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;flask中cookie和session介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/bingfeilongxin/article/details/88285305&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Go 语言 Session机制和 Cookie机制&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_8至3_14</title>
      <link>https://ouchaochao.github.io/post/go3_8to3_14/</link>
      <pubDate>Tue, 20 Aug 2019 22:07:19 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_8to3_14/</guid>
      <description>

&lt;h2 id=&#34;数据库连接&#34;&gt;数据库连接&lt;/h2&gt;

&lt;p&gt;首先先下载数据库连接工具：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/go-sql-driver/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;dbops&lt;/code&gt;文件夹中新建三个文件，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dbops
├── api.go
├── api_test.go  // 测试api
└── conn.go  // 连接数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看看mysql数据库的连接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//conn.go
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var (
	dbConn *sql.DB
	err error
)

func init()  {
	// 复用dbConn
	dbConn, err = sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:1@tcp(47.94.131.35:3306)/video?charset=utf8&amp;quot;)
	if err != nil{
		// 无法连接时抛出异常
		panic(err.Error())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接完数据库，接下来就是对数据库的增删改查了，下面分别按&lt;code&gt;用户&lt;/code&gt;，&lt;code&gt;视频&lt;/code&gt;，&lt;code&gt;评论&lt;/code&gt;这三个模块来展示怎么写代码和测试：&lt;/p&gt;

&lt;h2 id=&#34;用户&#34;&gt;用户&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;用户&lt;/code&gt;模块有三个功能，分别是增加、查询和删除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/utils&amp;quot;
)

/*
下面三个函数分别是：
	添加用户
	获取用户信息
	删除用户
*/
func AddUserCredential(loginName string, pwd string) error {
	// 千万不要用+号来连接query的各个部分, 不安全, 容易被撞库攻击
	//Prepare预编译, 更安全了, 会拦下撞库攻击
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO users (login_name, pwd) VALUES (?, ?)&amp;quot;)
	if err != nil {
		return err
	}
	// 执行, 将两个参数传到上面两个问号处
	_, err = stmtIns.Exec(loginName, pwd)
	if err != nil {
		return err
	}
	// defer 是栈退出的时候才调用, 性能会有些许损耗
	defer stmtIns.Close()
	return nil
}

func GetUserCredential(loginName string) (string, error) {
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT pwd FROM users WHERE login_name = ?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		// string 默认是没有内容的
		return &amp;quot;&amp;quot;, err
	}

	var pwd string
	err = stmtOut.QueryRow(loginName).Scan(&amp;amp;pwd)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return &amp;quot;&amp;quot;, err
	}
	defer stmtOut.Close()
	return pwd, nil
}

func DeleteUser(loginName string, pwd string) error {
	stmtDel, err := dbConn.Prepare(&amp;quot;DELETE FROM users WHERE login_name=? AND pwd=?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;DeleteUser error: %s&amp;quot;, err)
		return err
	}
	_, err = stmtDel.Exec(loginName, pwd)
	if err != nil {
		return err
	}

	stmtDel.Close()
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;包含对添加、查询和修改的代码，其中多了一个Reget函数，是为了测试删除函数是否起到作用而存在的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
package dbops

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;testing&amp;quot;
	&amp;quot;time&amp;quot;
)

var tempvid string

func clearTables() {
	// 初始化, 保证数据库每次都是新的
	dbConn.Exec(&amp;quot;truncate users&amp;quot;)
	dbConn.Exec(&amp;quot;truncate video_info&amp;quot;)
	dbConn.Exec(&amp;quot;truncate comments&amp;quot;)
	dbConn.Exec(&amp;quot;truncate sessions&amp;quot;)
}

func TestMain(m *testing.M) {
	clearTables()
	m.Run()
	clearTables()
}

/*
测试有关用户的函数
*/
func TestUserWorkFlow(t *testing.T) {
	t.Run(&amp;quot;Add&amp;quot;, testAddUser)
	t.Run(&amp;quot;Get&amp;quot;, testGetUser)
	t.Run(&amp;quot;Del&amp;quot;, testDeleteUser)
	t.Run(&amp;quot;Reget&amp;quot;, testRegetUser)
}

func testAddUser(t *testing.T) {
	err := AddUserCredential(&amp;quot;leo&amp;quot;, &amp;quot;123&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error of AddUser: %v&amp;quot;, err)
	}
}

func testGetUser(t *testing.T) {
	pwd, err := GetUserCredential(&amp;quot;leo&amp;quot;)
	if pwd != &amp;quot;123&amp;quot; || err != nil {
		t.Errorf(&amp;quot;Error get user&amp;quot;)
	}
}

func testDeleteUser(t *testing.T) {
	err := DeleteUser(&amp;quot;leo&amp;quot;, &amp;quot;123&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error delete user: %v&amp;quot;, err)
	}
}

func testRegetUser(t *testing.T) {
	pwd, err := GetUserCredential(&amp;quot;leo&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error of reget user: %v&amp;quot;, err)
	}
	if pwd != &amp;quot;&amp;quot; {
		t.Errorf(&amp;quot;Delete user test failed&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;视频&lt;/code&gt;包含了增加、查询和删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
/*
下面三个函数分别是：
	添加视频
	获取视频
	删除视频
*/
func AddVideoInfo(aid int, name string) (*defs.VideoInfo, error) {
	//Create uuid
	vid, err := utils.NewUUID()
	if err != nil {
		return nil, err
	}
	t := time.Now()
	// 时间格式, go的彩蛋
	ctime := t.Format(&amp;quot;Jan 02 2006, 15:04:05&amp;quot;)
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO video_info (id, author_id, name, display_ctime) VALUES (?,?,?,?)&amp;quot;)
	if err != nil {
		return nil, err
	}

	_, err = stmtIns.Exec(vid, aid, name, ctime)
	if err != nil {
		return nil, err
	}
	res := &amp;amp;defs.VideoInfo{Id: vid, AuthorId: aid, Name: name, DisplayCtime: ctime}
	defer stmtIns.Close()
	//怎么测试：res.XX
	return res, nil
}

func GetVideoInfo(vid string) (*defs.VideoInfo, error) {
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT author_id, name, display_ctime FROM video_info WHERE id=?&amp;quot;)

	//var不能写在一起
	var aid int
	var dct string
	var name string

	err = stmtOut.QueryRow(vid).Scan(&amp;amp;aid, &amp;amp;name, &amp;amp;dct)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return nil, err
	}

	if err == sql.ErrNoRows {
		return nil, nil
	}

	defer stmtOut.Close()
	res := &amp;amp;defs.VideoInfo{Id: vid, AuthorId: aid, Name: name, DisplayCtime: dct}
	return res, nil
}

func DeleteVideoInfo(vid string) error {
	stmtDel, err := dbConn.Prepare(&amp;quot;DELETE FROM video_info WHERE id=?&amp;quot;)
	if err != nil {
		return err
	}
	_, err = stmtDel.Exec(vid)
	if err != nil {
		return nil
	}
	defer stmtDel.Close()
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
/*
测试有关视频的函数，值得注意的是，添加视频前必须要有用户存在
*/
func TestVideoWorkFlow(t *testing.T) {
	clearTables()
	t.Run(&amp;quot;PrepareUser&amp;quot;, testAddUser)
	t.Run(&amp;quot;AddVideo&amp;quot;, testAddVideoInfo)
	t.Run(&amp;quot;GetVideo&amp;quot;, testGetVideoInfo)
	t.Run(&amp;quot;DelVideo&amp;quot;, testDeleteVideoInfo)
	t.Run(&amp;quot;RegetVideo&amp;quot;, testRegetVideoInfo)
}

func testAddVideoInfo(t *testing.T) {
	vi, err := AddVideoInfo(1, &amp;quot;my_video&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error add video: %v&amp;quot;, err)
	}
	tempvid = vi.Id
}

func testGetVideoInfo(t *testing.T) {
	_, err := GetVideoInfo(tempvid)
	if err != nil {
		t.Errorf(&amp;quot;Error get video: %v&amp;quot;, err)
	}
}

func testDeleteVideoInfo(t *testing.T) {
	err := DeleteVideoInfo(tempvid)
	if err != nil {
		t.Errorf(&amp;quot;Error del video:%v&amp;quot;, err)
	}
}
func testRegetVideoInfo(t *testing.T) {
	vi, err := GetVideoInfo(tempvid)
	if err != nil || vi != nil {
		t.Errorf(&amp;quot;Error reget video: %v&amp;quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;评论&#34;&gt;评论&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;评论&lt;/code&gt;包含了添加和查询，没有删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
/*
下面两个函数分别是：
	添加评论
	查看评论
	此处不添加删除评论
*/
func AddComments(vid string, aid int, content string) error {
	id, err := utils.NewUUID()
	if err != nil {
		return err
	}

	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO comments (id, video_id, author_id, content) VALUES (?,?,?,?)&amp;quot;)
	if err != nil {
		return err
	}

	_, err = stmtIns.Exec(id, vid, aid, content)
	if err != nil {
		return nil
	}
	defer stmtIns.Close()
	return nil
}

func ListComments(vid string, from, to int) ([]*defs.Comment, error) {
	// 连接user和comments表查询字段
	stmtOut, err := dbConn.Prepare(`SELECT comments.id, users.Login_name, comments.content FROM comments
		INNER JOIN users ON comments.author_id=users.id
		WHERE comments.video_id=? AND comments.time &amp;gt; FROM_UNIXTIME(?) AND comments.time &amp;lt;= FROM_UNIXTIME(?)`)

	//此处定义了Comment，放在了apidef.go文件中
	var res []*defs.Comment

	rows, err := stmtOut.Query(vid, from, to)
	if err != nil {
		return res, err
	}

	for rows.Next() {
		var id, name, content string
		if err := rows.Scan(&amp;amp;id, &amp;amp;name, &amp;amp;content); err != nil {
			return res, err
		}
		c := &amp;amp;defs.Comment{Id: id, VideoId: vid, Author: name, Content: content}
		res = append(res, c)
	}
	defer stmtOut.Close()
	return res, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附带一下定义了的结构体：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//apidef.go
package defs

type UserCredential struct {
	Username string `json:&amp;quot;username&amp;quot;`
	Pwd      string `json:&amp;quot;pwd&amp;quot;`
}

//Data model
type VideoInfo struct {
	Id           string
	AuthorId     int
	Name         string
	DisplayCtime string
}

type Comment struct {
	Id      string
	VideoId string
	Author  string
	Content string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
/*
测试有关评论的函数
*/
func TestComments(t *testing.T) {
	clearTables()
	t.Run(&amp;quot;AddUser&amp;quot;, testAddUser)
	t.Run(&amp;quot;AddComments&amp;quot;, testAddComments)
	t.Run(&amp;quot;ListComments&amp;quot;, testListComments)
}

func testAddComments(t *testing.T) {
	vid := &amp;quot;12345&amp;quot;
	aid := 1
	content := &amp;quot;test&amp;quot;

	err := AddComments(vid, aid, content)
	if err != nil {
		t.Errorf(&amp;quot;Error add comment: %v&amp;quot;, err)
	}
}

func testListComments(t *testing.T) {
	vid := &amp;quot;12345&amp;quot;
	from := 1514764800
	// 把当前时间转化成, 单位: 纳秒
	to, _ := strconv.Atoi(strconv.FormatInt(time.Now().UnixNano()/1000000000, 10))
	res, err := ListComments(vid, from, to)
	if err != nil {
		t.Errorf(&amp;quot;Error list comments: %v&amp;quot;, err)
	}

	for i, ele := range res {
		fmt.Printf(&amp;quot;comment:%d,%v\n&amp;quot;, i, ele)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总体来说，增删改查的代码很基础，也是重复的工作量，这里没有用到花里胡哨的技能，同时也@一下&lt;a href=&#34;https://github.com/dobio&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;颜威&lt;/a&gt;同学，在他那里学到了一个小技巧，就是每写一个函数就写一个测试函数，保证自己的代码能跑通，也能马上获得正反馈。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go自动化部署项目</title>
      <link>https://ouchaochao.github.io/post/developgo/</link>
      <pubDate>Sun, 18 Aug 2019 20:14:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/developgo/</guid>
      <description>&lt;p&gt;趁着有点时间学了一下&lt;a href=&#34;https://www.imooc.com/learn/910&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;DevOps和云计算初识&lt;/a&gt;, 发现一个以前没想到过的点 &amp;ndash; 自动化部署项目.&lt;/p&gt;

&lt;p&gt;这个项目是用Go写的, 大致的过程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 在本地写完代码之后, git push到github上
2. github里的Webhooks会被触发, 进而会访问一个设定好的网站
3. 这个网站就是DeployServer, 它会从github里git pull你刚push的代码
4. 代码返回到服务器
5. DeployServer停掉旧版本的WebServer, 然后运行最新的Webserver代码
6. 完成更新, 浏览器打开WebServer的网址就能访问最新的网页
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是Webhooks的示意图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是DeployServer的sh文件写法, 仅供参考:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_8</title>
      <link>https://ouchaochao.github.io/post/docker2_8/</link>
      <pubDate>Sun, 18 Aug 2019 20:13:31 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_8/</guid>
      <description>

&lt;h2 id=&#34;镜像的分布&#34;&gt;镜像的分布&lt;/h2&gt;

&lt;h3 id=&#34;docker-hub&#34;&gt;docker hub&lt;/h3&gt;

&lt;p&gt;首先在终端中登陆账号(账号在docker hub里注册)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是push自己的docker：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一：docker hub&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Usage:  docker push [OPTIONS] NAME[:TAG]
例如：
docker push ouchaochao/hello-world:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法不好的地方就是别人会担心你的docker里有病毒，所以一般使用方法二。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二：dockerfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过关联github和docker hub，我们只要在github上维护dockerfile就行了，docker hub会根据关联的dockerfile自动build好docker仓库。&lt;/p&gt;

&lt;p&gt;下面讲解如何关联github和docker hub：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开account setting:
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;往下找到linked accounts，绑定github
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在github中新建dockerfile项目
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在docker hub中绑定github的dockerfile
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成结果
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;搭建公司-自己的docker-hub&#34;&gt;搭建公司/自己的docker hub&lt;/h3&gt;

&lt;p&gt;docker hub 中搜索registry，linux系统中输入以下代码就完成了部署&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d -p 5000:5000 --restart always --name registry registry:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;怎么push&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;build的改变，把NAME部分换成ip地址，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build -t 47.94.131.35:5000/hello-world . # 换成自己的ip
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker image ls
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改docker下的daemon.json文件，把服务器添加信任，然后点Apply &amp;amp; Restart
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来就是push&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker push 47.94.131.35:5000/hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过在网页打开以下网站查看是否上传成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://47.94.131.35:5000/v2/_catalog

成功的话会有以下输出：
// 20190812013314
// http://47.94.131.35:5000/v2/_catalog

{
&amp;quot;repositories&amp;quot;: [
&amp;quot;hello-world&amp;quot;
]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Registry Api &lt;a href=&#34;https://docs.docker.com/registry/spec/api/#listing-repositories&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;网站&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_7</title>
      <link>https://ouchaochao.github.io/post/docker2_7/</link>
      <pubDate>Sun, 18 Aug 2019 20:12:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_7/</guid>
      <description>

&lt;h2 id=&#34;run-vs-cmd-vs-entrypoint&#34;&gt;run-vs-cmd-vs-entrypoint&lt;/h2&gt;

&lt;p&gt;首先明确一下概念:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;run:执行命令并创建新的 image layer
cmd:设置容器启动后默认执行的命令和参数
entrypoint:设置容器启动时运行的命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在介绍cmd和entrypoint之前,先了解一下shell和exec格式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos
RUN apt-get install -y vim
ENV name docker
CMD echo &amp;quot;hello docker&amp;quot;
ENTRYPOINT echo &amp;quot;hello $name &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exec&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos  
RUN [&amp;quot;apt-get&amp;quot;, &amp;quot;install&amp;quot;, &amp;quot;-y&amp;quot;, &amp;quot;vim&amp;quot;]
ENV name docker
CMD [&amp;quot;/bin/echo&amp;quot;, &amp;quot;hello docker&amp;quot;]
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,  &amp;quot;echo hello $name &amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;build一个docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd somefile
docker build -t cc/xxx .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmd&#34;&gt;CMD&lt;/h2&gt;

&lt;p&gt;容器启动时默认执行的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos
ENV name docker
CMD echo &amp;quot;hello $name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;情况一：如果docker run指定了其它命令，CMD命令被忽略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -it [image] /bin/bsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;情况二：如果定义了多个CMD，只有最后一个执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;...
CMD echo &amp;quot;hello ab&amp;quot;
CMD echo &amp;quot;hello $name&amp;quot;  # 只执行这个
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;entrypoint&#34;&gt;ENTRYPOINT&lt;/h2&gt;

&lt;p&gt;让容器以应用程序或者服务的形式运行
特点：不会被忽略，一定执行
最佳实践：写一个shell脚本作为entrypoint&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;COPY docker-entrypoint.sh /usr/local/bin
ENTRYPOINT [&amp;quot;docker-entrypoint.sh&amp;quot;]
EXPOSE 27017
CMD [&amp;quot;mongoDB&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_6</title>
      <link>https://ouchaochao.github.io/post/docker2_6/</link>
      <pubDate>Sun, 18 Aug 2019 20:11:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_6/</guid>
      <description>

&lt;h2 id=&#34;dockerfile语法梳理&#34;&gt;dockerfile语法梳理&lt;/h2&gt;

&lt;h3 id=&#34;from-从哪里构建image&#34;&gt;FROM：从哪里构建image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM scratch # 制作base image
FROM centos # 使用base image
FROM ubuntu:18.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：为了安全，请使用官方的image&lt;/p&gt;

&lt;h3 id=&#34;label-标签&#34;&gt;LABEL：标签&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LABEL maintainer=&amp;quot;abc@gmail.com&amp;quot;
LABEL version=&amp;quot;1.1&amp;quot;
LABEL description=&amp;quot;This is description&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：Metadata不可少！&lt;/p&gt;

&lt;h3 id=&#34;run&#34;&gt;RUN&lt;/h3&gt;

&lt;p&gt;为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;RUN yum update &amp;amp;&amp;amp; yum install -y vim \
    python-dev # 反斜线换行
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y perl\
    pwgen --no-install-recommends &amp;amp;&amp;amp; rm -rf \
    /var/lib/apt/list/* # 注意清理cache
RUN /bin/bash -c &#39;source $HOME/.bashrc; echo
    $HOME&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;workdir-设定当前工作目录&#34;&gt;WORKDIR：设定当前工作目录&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
WORKDIR /test # 如果没有，会自动创建的
WORKDIR demo
RUN pwd # 输出结果应该是 /test/demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：不要用RUN cd代替WORKDIR，尽量使用绝对目录&lt;/p&gt;

&lt;h3 id=&#34;add和copy&#34;&gt;ADD和COPY&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ADD hello /
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ADD test.tar.gz # 添加到根目录并解压
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
ADD hello test # /root/test/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
COPY hello test # /root/test/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分情况copy优于add
add除了copy功能外，还附带解压缩
添加远程文件/目录请使用curl或者wget&lt;/p&gt;

&lt;h3 id=&#34;env-定义常量&#34;&gt;ENV 定义常量&lt;/h3&gt;

&lt;p&gt;env可增加可维护性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ENV MYSQL_VERSION 5.6
RUN apt-get install -y mysql-server= &amp;quot;${MYSQL_VERSION}&amp;quot; \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* # 引用常量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/docker-library/mysql/blob/master/5.6/Dockerfile&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Dockerfile Demo Time&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_5</title>
      <link>https://ouchaochao.github.io/post/docker2_5/</link>
      <pubDate>Sun, 18 Aug 2019 20:09:45 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_5/</guid>
      <description>

&lt;h2 id=&#34;构建自己的docker镜像&#34;&gt;构建自己的Docker镜像&lt;/h2&gt;

&lt;h3 id=&#34;把一个container-commit成自己的&#34;&gt;把一个Container commit成自己的&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -it centos
$ yum install -y vim
$ docker commit container_name cc/centos-vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用dockerfile构建-推荐&#34;&gt;用dockerfile构建（推荐）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir centos-vim 
$ cd centos-vim
$ vim Dockerfile

FROM centos
RUN yum install -y vim # 思考为什么image只读却可以写

$ docker build -t cc/centos-vim .
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_4</title>
      <link>https://ouchaochao.github.io/post/docker2_4/</link>
      <pubDate>Sun, 18 Aug 2019 20:09:02 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_4/</guid>
      <description>

&lt;h2 id=&#34;初识container系统&#34;&gt;初识Container系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过Image创建（copy）&lt;/li&gt;
&lt;li&gt;在Image layer之上建立一个container layer（可读写）&lt;/li&gt;
&lt;li&gt;类比面向对象：类和实例&lt;/li&gt;
&lt;li&gt;Image负责app的存储和分发，Container负责运行app&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_4_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker交互 -it
docker run -it centos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-的一些命令&#34;&gt;Docker 的一些命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker --help
docker container --help
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_3</title>
      <link>https://ouchaochao.github.io/post/docker2_3/</link>
      <pubDate>Sun, 18 Aug 2019 20:07:02 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_3/</guid>
      <description>

&lt;h2 id=&#34;diy-base-image&#34;&gt;DIY-Base-Image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 将docker加入管理员，以后使用docker不用再加sudo
$ sudo groupadd docker
$ sudo gpasswd -a username docker
# 完成后重启命令行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来建立自己的docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir halo
$ cd halo
$ vim halo.c

#include&amp;lt;stdio.h&amp;gt;
int main()
{
printf(&amp;quot;halo done!\n&amp;quot;);
}

$ gcc -static halo.c -o halo
$ vim Dockerfile

FROM scratch
ADD halo /
CMD [&amp;quot;/halo&amp;quot;]

$ docker build -t cc/halo .
$ docker run cc/halo
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_2</title>
      <link>https://ouchaochao.github.io/post/docker2_2/</link>
      <pubDate>Sun, 18 Aug 2019 20:06:16 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_2/</guid>
      <description>

&lt;h2 id=&#34;什么是image&#34;&gt;什么是Image&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件和meta data的集合（root file system）&lt;/li&gt;
&lt;li&gt;分层的， 并且每一层都可以添加改变删除文件成为一个新的image&lt;/li&gt;
&lt;li&gt;不同的image可以共享相同的layer&lt;/li&gt;
&lt;li&gt;Image本身是read-only&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_2_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;image的获取&#34;&gt;Image的获取&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Build from Dockerfile&lt;/li&gt;
&lt;li&gt;Pull from Registry&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_1</title>
      <link>https://ouchaochao.github.io/post/docker2_1/</link>
      <pubDate>Sun, 18 Aug 2019 20:05:28 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_1/</guid>
      <description>

&lt;h2 id=&#34;docker架构和底层技术简介系统学习&#34;&gt;Docker架构和底层技术简介系统学习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker提供一个开发、打包、运行app的平台&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把app和底层infrastructure隔离开&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker engine&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;后台进程（dockerd）&lt;/li&gt;
&lt;li&gt;REST API Server&lt;/li&gt;
&lt;li&gt;CLI接口（docker）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker architecture&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_3.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;底层技术支持&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;namespaces: 做隔离pid, net, ipc, mnt, uts&lt;/li&gt;
&lt;li&gt;control groups: 做资源限制&lt;/li&gt;
&lt;li&gt;union file systems: container 和 image的分层&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念1</title>
      <link>https://ouchaochao.github.io/post/docker1/</link>
      <pubDate>Sun, 18 Aug 2019 20:04:20 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker1/</guid>
      <description>

&lt;h2 id=&#34;docker是什么&#34;&gt;docker是什么&lt;/h2&gt;

&lt;p&gt;Docker 是一个&lt;a href=&#34;https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;开源&lt;/a&gt;的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 &lt;a href=&#34;https://baike.baidu.com/item/Linux&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;或Windows 机器上，也可以实现&lt;a href=&#34;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;虚拟化&lt;/a&gt;。容器是完全使用&lt;a href=&#34;https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;沙箱&lt;/a&gt;机制，相互之间不会有任何接口。&lt;/p&gt;

&lt;p&gt;说人话就是，docker把环境封装成一个集装箱，集装箱之间的环境（如python2/3）不会相互干扰。&lt;/p&gt;

&lt;h2 id=&#34;安装docker&#34;&gt;安装docker&lt;/h2&gt;

&lt;p&gt;请对应自己的系统点击以下链接进行安装：
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;centos&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;debain&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/fedora/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;fedora&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ubuntu&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/docker-for-mac/install/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;mac&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/docker-for-windows/install/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;windows&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>