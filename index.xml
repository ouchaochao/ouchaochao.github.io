<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ouchaochao.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 06 Sep 2019 22:47:36 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>富途现场笔试感受</title>
      <link>https://ouchaochao.github.io/post/%E5%AF%8C%E9%80%94%E7%8E%B0%E5%9C%BA%E7%AC%94%E8%AF%95%E6%84%9F%E5%8F%97/</link>
      <pubDate>Fri, 06 Sep 2019 22:47:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/%E5%AF%8C%E9%80%94%E7%8E%B0%E5%9C%BA%E7%AC%94%E8%AF%95%E6%84%9F%E5%8F%97/</guid>
      <description>&lt;p&gt;今晚去了富途的宣讲会，感觉这是一个朝气蓬勃的公司，我自己而言是非常喜欢互联网和金融这两块内容的，所以还是很希望自己能进入这样的公司。&lt;/p&gt;

&lt;p&gt;讲讲现场笔试吧。真的是许久没有手写过笔试题了，很怀念的感觉，一共90分钟，做的是后台的题目，考的内容包括数据结构、计算机网络、操作系统、数据库，题型包括选择题、填空题和编程题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择题&lt;/strong&gt;做的比较顺畅，里面有几道智力题，其中有一道是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;有4个人，ABCD，每个人都头上都带了个帽子，帽子只有黑色或白色，4个人中分别有两个人带黑色，有两个人带白色，4个人的站位是A|B C D,|是一堵墙，B，C，D分别站在平地，一层台阶，二层台阶上，每个人都看不到自己带的帽子，一开始大家都不讲话，突然有个人说，我知道自己带的什么颜色的帽子了，请问是谁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想了很久也没有想出来，觉得可能出错题？于是就填了D，上网看了一下答案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;是C或者D
理由如下：首先考虑C，他看见D和B的帽子，但是他没有推理出自己的颜色（一开始大家都不讲话），所以B和D异色。
同样的由于D也没有推理出自己的颜色，于是C和B异色。
此时，C明白过来，因为D也没有推理出自己的颜色，于是自己和D共色，于是他便说出了D头上帽子的颜色便是自己的颜色。
由于A和B相当于什么都看不见，仅仅凭着别人的推理只能知道共边关系，但是由于没有初始条件，不知道某一帽子的配置，于是无法推知自己帽子的颜色
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它的选择题做的还算顺利。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;填空题&lt;/strong&gt;就有点难受了，忘了MySQL怎么写查询了，略尴尬，问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;查询出每个部门的人员总数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;select count(人员id) from 部门人员表 group by 部门编号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一道网络的题目，计算包大小的，包越大丢包率越大，要怎么设计，表示不会。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编程题&lt;/strong&gt;是写计算地铁票该算多少钱的，这道题感觉自己都写对了？emmm，蜜汁自信。&lt;/p&gt;

&lt;p&gt;总的来说，经历了第一次笔试，感觉很良好，同时也发现自己有很多的不足，趁着还有点时间多看看书吧，2333&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_15至3_18</title>
      <link>https://ouchaochao.github.io/post/go3_15to3_16/</link>
      <pubDate>Tue, 20 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_15to3_16/</guid>
      <description>

&lt;h2 id=&#34;聊聊session&#34;&gt;聊聊session&lt;/h2&gt;

&lt;p&gt;在了解session之前先要了解什么是cookie:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么是session？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://img.ouchaochao.cn/go/3_15_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;cookie和session结合使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1、存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Session 创建过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当用户访问Web应用时，服务端程序会随需要创建session，这个过程可以概括为三个步骤：

生成全局唯一标识符（sessionid）；
开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，当然这样会增加 I/O 开销，但是它可以实现某种程度的 session 持久化，也更有利于 session 的共享；
将 session 的全局唯一标示符发送给客户端。
以上三个步骤中，最关键的是如何发送这个 session 的唯一标识这一步上。考虑到 HTTP 协议的定义，数据无非可以放到请求行、头域或 Body 里，所以一般来说会有两种常用的方式： cookie 和 URL 重写。

Cookie 服务端通过设置 Set-cookie 头就可以将 session 的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，另外一般包含 session 信息的 cookie 会将失效时间设置为0(会话 cookie)，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大(一般体现在新建浏览器窗口的时候)；
URL重写， 所谓URL重写，就是在返回给用户的页面里的所有的URL后面追加session标识符，这样用户在收到响应之后，无论点击响应页面里的哪个链接或提交表单，都会自动带上session标识符，从而就实现了会话的保持。虽然这种做法比较麻烦，但是，如果客户端禁用了cookie的话，此种方案将会是首选。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;go中的session&#34;&gt;GO中的session&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;流程
main-&amp;gt;middleware-&amp;gt;defs(message, err)-&amp;gt;handlers-&amp;gt;dbops-&amp;gt;response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;main.go&lt;/code&gt;中添加&lt;code&gt;middleware&lt;/code&gt;，在&lt;code&gt;middleware&lt;/code&gt;中处理校验、健全、流控等：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//main.go
package main

import (
	&amp;quot;github.com/julienschmidt/httprouter&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;video/api/handlers&amp;quot;
)

type middleWareHandler struct {
	r *httprouter.Router
}

func NewMiddleWareHandler(r *httprouter.Router) http.Handler {
	m := middleWareHandler{}
	m.r = r
	return m
}
func (m middleWareHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	//check session
	handlers.ValidateUserSession(r)
	m.r.ServeHTTP(w, r)
}

func RegisterHandlers() *httprouter.Router {
	router := httprouter.New()
	router.POST(&amp;quot;/user&amp;quot;, handlers.CreateUser)
	router.POST(&amp;quot;/user/:username&amp;quot;, handlers.Login)
	return router
}

func main() {
	r := RegisterHandlers()
	mh := NewMiddleWareHandler(r)
	http.ListenAndServe(&amp;quot;:8000&amp;quot;, mh)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;NewMiddleWareHandler&lt;/code&gt;用到duck type。调用过程如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NewMiddleWareHandler&lt;/code&gt;-&amp;gt;&lt;code&gt;middleWareHandler&lt;/code&gt;-&amp;gt;&lt;code&gt;ServeHTTP&lt;/code&gt;-&amp;gt;&lt;code&gt;auth.go&lt;/code&gt;用户合法校验放在这里面，&lt;code&gt;response.go&lt;/code&gt;返回消息-&amp;gt;&lt;code&gt;ops.go&lt;/code&gt;session的产生和验证过期否 -&amp;gt;&lt;code&gt;internal.go&lt;/code&gt;数据库的增删查session&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
auth.go
文件初始化
 */
package handlers

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/session&amp;quot;
)

//X开头的都是自定义的header,加到原生http header调用里面,构成整个健全过程
var HEADER_FIELD_SESSION = &amp;quot;X-Session-Id&amp;quot;
var HEADER_FAILD_UNAME = &amp;quot;X-User-Name&amp;quot;

//检测用户session是否合法，是就返回username
func ValidateUserSession(r *http.Request) bool {
	//get获取sessionId
	sid := r.Header.Get(HEADER_FIELD_SESSION)
	if len(sid) == 0 {
		return false
	}

	//检测过期否?
	uname, ok := session.IsSessionExpired(sid)
	if ok {
		return false
	}

	r.Header.Add(HEADER_FAILD_UNAME, uname)
	return true
}

func ValidateUser(w http.ResponseWriter, r *http.Request) bool {
	uname := r.Header.Get(HEADER_FAILD_UNAME)
	if len(uname) == 0 {
		sendErrorResponse(w, defs.ErrorNotAuthUser)
		return false
	}
	return true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// session ops.go
package session

import (
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;video/api/dbops&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/utils&amp;quot;
)

//sync.Map自己实现了一套线程安全的机制,优化了并发读,写的话要加锁
var sessionMap *sync.Map

func init() {
	sessionMap = &amp;amp;sync.Map{}
}

//从数据库读取sessionId到cache
func LoadSessionsFromDB() {
	r, err := dbops.RetrieveAllSessions()
	if err != nil {
		//不对外返回东西
		return
	}

	//返回值
	r.Range(func(k, v interface{}) bool {
		ss := v.(*defs.SimpleSession)
		sessionMap.Store(k, ss)
		return true
	})
}


func nowInMilli() int64 {
	//UnixNano纳秒级别, &#39;/ 100000&#39;后变成毫秒级别
	return time.Now().UnixNano() / 100000
}
//产生sessionId
func GenerateNewSessionId(un string) string {
	id, _ := utils.NewUUID()
	ct := nowInMilli()
	//过期时间30min(单位:毫秒)
	ttl := ct + 30*60*1000

	ss := &amp;amp;defs.SimpleSession{Username: un, TTL: ttl}
	sessionMap.Store(id, ss)
	dbops.InsertSession(id, ttl, un)
	return id

}

//session过期否?
func IsSessionExpired(sid string) (string, bool) {
	ss, ok := sessionMap.Load(sid)
	if ok {
		ct := nowInMilli()
		if ss.(*defs.SimpleSession).TTL &amp;lt; ct {
			deleteExpieredSession(sid)
			return &amp;quot;&amp;quot;, true
		}
		return ss.(*defs.SimpleSession).Username, false
	}
	return &amp;quot;&amp;quot;, true
}
//删除过期的session
func deleteExpieredSession(sid string) {
	sessionMap.Delete(sid)
	dbops.DeleteSession(sid)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//response.go
package handlers

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
)

func sendErrorResponse(w http.ResponseWriter, errResp defs.ErrResponse) {
	w.WriteHeader(errResp.HttpSC)

	//Marshal:struct序列化成json
	resStr, _ := json.Marshal(&amp;amp;errResp.Error)
	io.WriteString(w, string(resStr))
}

func sendNormalResponse(w http.ResponseWriter, resp string, sc int) {
	w.WriteHeader(sc)
	io.WriteString(w, resp)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//internal.go
/*
和session相关的db操作单独放在这个文件中
 */
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
)

//往DB中插入session
func InsertSession(sid string, ttl int64, uname string) error {
	/*
	strconv是golang用来做数据类型转换的一个库
	FormatInt 将十进制的Int类型转换为String类型
	ParseInt 将字符串转换为值
	最常见的数值转换是 Atoi(string to int)和 Itoa(int to string)
	*/
	ttlstr := strconv.FormatInt(ttl, 10)
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO sessions (session_id, TTL, login_name) VALUES (?, ?, ?)&amp;quot;)
	if err != nil {
		return err
	}

	_, err = stmtIns.Exec(sid, ttlstr, uname)
	if err != nil {
		return err
	}

	defer stmtIns.Close()
	return nil
}

func RetrieveSession(sid string) (*defs.SimpleSession, error) {
	ss := &amp;amp;defs.SimpleSession{}
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT TTL, login_name FROM sessions WHERE session_id=?&amp;quot;)
	if err != nil {
		return nil, err
	}

	var ttl string
	var uname string
	stmtOut.QueryRow(sid).Scan(&amp;amp;ttl, &amp;amp;uname)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return nil, err
	}

	if res, err := strconv.ParseInt(ttl, 10, 64); err == nil {
		ss.TTL = res
		ss.Username = uname
	} else {
		return nil, err
	}
	defer stmtOut.Close()
	return ss, nil
}

//sessions放在map里,一块返回
func RetrieveAllSessions() (*sync.Map, error) {
	m := &amp;amp;sync.Map{}
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT * FROM sessions&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		return nil, err
	}

	rows, err := stmtOut.Query()
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		return nil, err
	}

	for rows.Next() {
		var id string
		var ttlstr string
		var login_name string
		if er := rows.Scan(&amp;amp;id, &amp;amp;ttlstr, &amp;amp;login_name); er != nil {
			log.Printf(&amp;quot;retrive sessions error: %s&amp;quot;, er)
			break
		}
		if ttl, err1 := strconv.ParseInt(ttlstr, 10, 64); err1 == nil {
			ss := &amp;amp;defs.SimpleSession{Username: login_name, TTL: ttl}
			m.Store(id, ss)
			log.Printf(&amp;quot;session id: %s,ttl:%d&amp;quot;, id, ss.TTL)
		}
	}
	return m, nil
}

func DeleteSession(sid string) error {
	stmtOut, err := dbConn.Prepare(&amp;quot;DELETE FROM sessions WHERE session_id=?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		return err
	}

	if _, err := stmtOut.Query(sid); err != nil {
		return err
	}
	return nil

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;至此session部分和middleware部分告一段落，但是关于middleware的这个调用过程还不是很熟悉，需要再加深理解。&lt;/p&gt;

&lt;h2 id=&#34;refers&#34;&gt;Refers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/xxtalhr/p/9053906.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;flask中cookie和session介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/bingfeilongxin/article/details/88285305&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Go 语言 Session机制和 Cookie机制&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_8至3_14</title>
      <link>https://ouchaochao.github.io/post/go3_8to3_14/</link>
      <pubDate>Tue, 20 Aug 2019 22:07:19 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_8to3_14/</guid>
      <description>

&lt;h2 id=&#34;数据库连接&#34;&gt;数据库连接&lt;/h2&gt;

&lt;p&gt;首先先下载数据库连接工具：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/go-sql-driver/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;dbops&lt;/code&gt;文件夹中新建三个文件，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dbops
├── api.go
├── api_test.go  // 测试api
└── conn.go  // 连接数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看看mysql数据库的连接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//conn.go
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var (
	dbConn *sql.DB
	err error
)

func init()  {
	// 复用dbConn
	dbConn, err = sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:1@tcp(47.94.131.35:3306)/video?charset=utf8&amp;quot;)
	if err != nil{
		// 无法连接时抛出异常
		panic(err.Error())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接完数据库，接下来就是对数据库的增删改查了，下面分别按&lt;code&gt;用户&lt;/code&gt;，&lt;code&gt;视频&lt;/code&gt;，&lt;code&gt;评论&lt;/code&gt;这三个模块来展示怎么写代码和测试：&lt;/p&gt;

&lt;h2 id=&#34;用户&#34;&gt;用户&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;用户&lt;/code&gt;模块有三个功能，分别是增加、查询和删除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/utils&amp;quot;
)

/*
下面三个函数分别是：
	添加用户
	获取用户信息
	删除用户
*/
func AddUserCredential(loginName string, pwd string) error {
	// 千万不要用+号来连接query的各个部分, 不安全, 容易被撞库攻击
	//Prepare预编译, 更安全了, 会拦下撞库攻击
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO users (login_name, pwd) VALUES (?, ?)&amp;quot;)
	if err != nil {
		return err
	}
	// 执行, 将两个参数传到上面两个问号处
	_, err = stmtIns.Exec(loginName, pwd)
	if err != nil {
		return err
	}
	// defer 是栈退出的时候才调用, 性能会有些许损耗
	defer stmtIns.Close()
	return nil
}

func GetUserCredential(loginName string) (string, error) {
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT pwd FROM users WHERE login_name = ?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		// string 默认是没有内容的
		return &amp;quot;&amp;quot;, err
	}

	var pwd string
	err = stmtOut.QueryRow(loginName).Scan(&amp;amp;pwd)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return &amp;quot;&amp;quot;, err
	}
	defer stmtOut.Close()
	return pwd, nil
}

func DeleteUser(loginName string, pwd string) error {
	stmtDel, err := dbConn.Prepare(&amp;quot;DELETE FROM users WHERE login_name=? AND pwd=?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;DeleteUser error: %s&amp;quot;, err)
		return err
	}
	_, err = stmtDel.Exec(loginName, pwd)
	if err != nil {
		return err
	}

	stmtDel.Close()
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;包含对添加、查询和修改的代码，其中多了一个Reget函数，是为了测试删除函数是否起到作用而存在的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
package dbops

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;testing&amp;quot;
	&amp;quot;time&amp;quot;
)

var tempvid string

func clearTables() {
	// 初始化, 保证数据库每次都是新的
	dbConn.Exec(&amp;quot;truncate users&amp;quot;)
	dbConn.Exec(&amp;quot;truncate video_info&amp;quot;)
	dbConn.Exec(&amp;quot;truncate comments&amp;quot;)
	dbConn.Exec(&amp;quot;truncate sessions&amp;quot;)
}

func TestMain(m *testing.M) {
	clearTables()
	m.Run()
	clearTables()
}

/*
测试有关用户的函数
*/
func TestUserWorkFlow(t *testing.T) {
	t.Run(&amp;quot;Add&amp;quot;, testAddUser)
	t.Run(&amp;quot;Get&amp;quot;, testGetUser)
	t.Run(&amp;quot;Del&amp;quot;, testDeleteUser)
	t.Run(&amp;quot;Reget&amp;quot;, testRegetUser)
}

func testAddUser(t *testing.T) {
	err := AddUserCredential(&amp;quot;leo&amp;quot;, &amp;quot;123&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error of AddUser: %v&amp;quot;, err)
	}
}

func testGetUser(t *testing.T) {
	pwd, err := GetUserCredential(&amp;quot;leo&amp;quot;)
	if pwd != &amp;quot;123&amp;quot; || err != nil {
		t.Errorf(&amp;quot;Error get user&amp;quot;)
	}
}

func testDeleteUser(t *testing.T) {
	err := DeleteUser(&amp;quot;leo&amp;quot;, &amp;quot;123&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error delete user: %v&amp;quot;, err)
	}
}

func testRegetUser(t *testing.T) {
	pwd, err := GetUserCredential(&amp;quot;leo&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error of reget user: %v&amp;quot;, err)
	}
	if pwd != &amp;quot;&amp;quot; {
		t.Errorf(&amp;quot;Delete user test failed&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;视频&lt;/code&gt;包含了增加、查询和删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
/*
下面三个函数分别是：
	添加视频
	获取视频
	删除视频
*/
func AddVideoInfo(aid int, name string) (*defs.VideoInfo, error) {
	//Create uuid
	vid, err := utils.NewUUID()
	if err != nil {
		return nil, err
	}
	t := time.Now()
	// 时间格式, go的彩蛋
	ctime := t.Format(&amp;quot;Jan 02 2006, 15:04:05&amp;quot;)
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO video_info (id, author_id, name, display_ctime) VALUES (?,?,?,?)&amp;quot;)
	if err != nil {
		return nil, err
	}

	_, err = stmtIns.Exec(vid, aid, name, ctime)
	if err != nil {
		return nil, err
	}
	res := &amp;amp;defs.VideoInfo{Id: vid, AuthorId: aid, Name: name, DisplayCtime: ctime}
	defer stmtIns.Close()
	//怎么测试：res.XX
	return res, nil
}

func GetVideoInfo(vid string) (*defs.VideoInfo, error) {
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT author_id, name, display_ctime FROM video_info WHERE id=?&amp;quot;)

	//var不能写在一起
	var aid int
	var dct string
	var name string

	err = stmtOut.QueryRow(vid).Scan(&amp;amp;aid, &amp;amp;name, &amp;amp;dct)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return nil, err
	}

	if err == sql.ErrNoRows {
		return nil, nil
	}

	defer stmtOut.Close()
	res := &amp;amp;defs.VideoInfo{Id: vid, AuthorId: aid, Name: name, DisplayCtime: dct}
	return res, nil
}

func DeleteVideoInfo(vid string) error {
	stmtDel, err := dbConn.Prepare(&amp;quot;DELETE FROM video_info WHERE id=?&amp;quot;)
	if err != nil {
		return err
	}
	_, err = stmtDel.Exec(vid)
	if err != nil {
		return nil
	}
	defer stmtDel.Close()
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
/*
测试有关视频的函数，值得注意的是，添加视频前必须要有用户存在
*/
func TestVideoWorkFlow(t *testing.T) {
	clearTables()
	t.Run(&amp;quot;PrepareUser&amp;quot;, testAddUser)
	t.Run(&amp;quot;AddVideo&amp;quot;, testAddVideoInfo)
	t.Run(&amp;quot;GetVideo&amp;quot;, testGetVideoInfo)
	t.Run(&amp;quot;DelVideo&amp;quot;, testDeleteVideoInfo)
	t.Run(&amp;quot;RegetVideo&amp;quot;, testRegetVideoInfo)
}

func testAddVideoInfo(t *testing.T) {
	vi, err := AddVideoInfo(1, &amp;quot;my_video&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error add video: %v&amp;quot;, err)
	}
	tempvid = vi.Id
}

func testGetVideoInfo(t *testing.T) {
	_, err := GetVideoInfo(tempvid)
	if err != nil {
		t.Errorf(&amp;quot;Error get video: %v&amp;quot;, err)
	}
}

func testDeleteVideoInfo(t *testing.T) {
	err := DeleteVideoInfo(tempvid)
	if err != nil {
		t.Errorf(&amp;quot;Error del video:%v&amp;quot;, err)
	}
}
func testRegetVideoInfo(t *testing.T) {
	vi, err := GetVideoInfo(tempvid)
	if err != nil || vi != nil {
		t.Errorf(&amp;quot;Error reget video: %v&amp;quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;评论&#34;&gt;评论&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;评论&lt;/code&gt;包含了添加和查询，没有删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
/*
下面两个函数分别是：
	添加评论
	查看评论
	此处不添加删除评论
*/
func AddComments(vid string, aid int, content string) error {
	id, err := utils.NewUUID()
	if err != nil {
		return err
	}

	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO comments (id, video_id, author_id, content) VALUES (?,?,?,?)&amp;quot;)
	if err != nil {
		return err
	}

	_, err = stmtIns.Exec(id, vid, aid, content)
	if err != nil {
		return nil
	}
	defer stmtIns.Close()
	return nil
}

func ListComments(vid string, from, to int) ([]*defs.Comment, error) {
	// 连接user和comments表查询字段
	stmtOut, err := dbConn.Prepare(`SELECT comments.id, users.Login_name, comments.content FROM comments
		INNER JOIN users ON comments.author_id=users.id
		WHERE comments.video_id=? AND comments.time &amp;gt; FROM_UNIXTIME(?) AND comments.time &amp;lt;= FROM_UNIXTIME(?)`)

	//此处定义了Comment，放在了apidef.go文件中
	var res []*defs.Comment

	rows, err := stmtOut.Query(vid, from, to)
	if err != nil {
		return res, err
	}

	for rows.Next() {
		var id, name, content string
		if err := rows.Scan(&amp;amp;id, &amp;amp;name, &amp;amp;content); err != nil {
			return res, err
		}
		c := &amp;amp;defs.Comment{Id: id, VideoId: vid, Author: name, Content: content}
		res = append(res, c)
	}
	defer stmtOut.Close()
	return res, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附带一下定义了的结构体：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//apidef.go
package defs

type UserCredential struct {
	Username string `json:&amp;quot;username&amp;quot;`
	Pwd      string `json:&amp;quot;pwd&amp;quot;`
}

//Data model
type VideoInfo struct {
	Id           string
	AuthorId     int
	Name         string
	DisplayCtime string
}

type Comment struct {
	Id      string
	VideoId string
	Author  string
	Content string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
/*
测试有关评论的函数
*/
func TestComments(t *testing.T) {
	clearTables()
	t.Run(&amp;quot;AddUser&amp;quot;, testAddUser)
	t.Run(&amp;quot;AddComments&amp;quot;, testAddComments)
	t.Run(&amp;quot;ListComments&amp;quot;, testListComments)
}

func testAddComments(t *testing.T) {
	vid := &amp;quot;12345&amp;quot;
	aid := 1
	content := &amp;quot;test&amp;quot;

	err := AddComments(vid, aid, content)
	if err != nil {
		t.Errorf(&amp;quot;Error add comment: %v&amp;quot;, err)
	}
}

func testListComments(t *testing.T) {
	vid := &amp;quot;12345&amp;quot;
	from := 1514764800
	// 把当前时间转化成, 单位: 纳秒
	to, _ := strconv.Atoi(strconv.FormatInt(time.Now().UnixNano()/1000000000, 10))
	res, err := ListComments(vid, from, to)
	if err != nil {
		t.Errorf(&amp;quot;Error list comments: %v&amp;quot;, err)
	}

	for i, ele := range res {
		fmt.Printf(&amp;quot;comment:%d,%v\n&amp;quot;, i, ele)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总体来说，增删改查的代码很基础，也是重复的工作量，这里没有用到花里胡哨的技能，同时也@一下&lt;a href=&#34;https://github.com/dobio&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;颜威&lt;/a&gt;同学，在他那里学到了一个小技巧，就是每写一个函数就写一个测试函数，保证自己的代码能跑通，也能马上获得正反馈。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go自动化部署项目</title>
      <link>https://ouchaochao.github.io/post/developgo/</link>
      <pubDate>Sun, 18 Aug 2019 20:14:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/developgo/</guid>
      <description>&lt;p&gt;趁着有点时间学了一下&lt;a href=&#34;https://www.imooc.com/learn/910&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;DevOps和云计算初识&lt;/a&gt;, 发现一个以前没想到过的点 &amp;ndash; 自动化部署项目.&lt;/p&gt;

&lt;p&gt;这个项目是用Go写的, 大致的过程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 在本地写完代码之后, git push到github上
2. github里的Webhooks会被触发, 进而会访问一个设定好的网站
3. 这个网站就是DeployServer, 它会从github里git pull你刚push的代码
4. 代码返回到服务器
5. DeployServer停掉旧版本的WebServer, 然后运行最新的Webserver代码
6. 完成更新, 浏览器打开WebServer的网址就能访问最新的网页
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是Webhooks的示意图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是DeployServer的sh文件写法, 仅供参考:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_8</title>
      <link>https://ouchaochao.github.io/post/docker2_8/</link>
      <pubDate>Sun, 18 Aug 2019 20:13:31 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_8/</guid>
      <description>

&lt;h2 id=&#34;镜像的分布&#34;&gt;镜像的分布&lt;/h2&gt;

&lt;h3 id=&#34;docker-hub&#34;&gt;docker hub&lt;/h3&gt;

&lt;p&gt;首先在终端中登陆账号(账号在docker hub里注册)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是push自己的docker：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一：docker hub&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Usage:  docker push [OPTIONS] NAME[:TAG]
例如：
docker push ouchaochao/hello-world:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法不好的地方就是别人会担心你的docker里有病毒，所以一般使用方法二。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二：dockerfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过关联github和docker hub，我们只要在github上维护dockerfile就行了，docker hub会根据关联的dockerfile自动build好docker仓库。&lt;/p&gt;

&lt;p&gt;下面讲解如何关联github和docker hub：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开account setting:
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;往下找到linked accounts，绑定github
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在github中新建dockerfile项目
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在docker hub中绑定github的dockerfile
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成结果
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;搭建公司-自己的docker-hub&#34;&gt;搭建公司/自己的docker hub&lt;/h3&gt;

&lt;p&gt;docker hub 中搜索registry，linux系统中输入以下代码就完成了部署&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d -p 5000:5000 --restart always --name registry registry:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;怎么push&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;build的改变，把NAME部分换成ip地址，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build -t 47.94.131.35:5000/hello-world . # 换成自己的ip
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker image ls
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改docker下的daemon.json文件，把服务器添加信任，然后点Apply &amp;amp; Restart
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来就是push&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker push 47.94.131.35:5000/hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过在网页打开以下网站查看是否上传成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://47.94.131.35:5000/v2/_catalog

成功的话会有以下输出：
// 20190812013314
// http://47.94.131.35:5000/v2/_catalog

{
&amp;quot;repositories&amp;quot;: [
&amp;quot;hello-world&amp;quot;
]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Registry Api &lt;a href=&#34;https://docs.docker.com/registry/spec/api/#listing-repositories&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;网站&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_7</title>
      <link>https://ouchaochao.github.io/post/docker2_7/</link>
      <pubDate>Sun, 18 Aug 2019 20:12:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_7/</guid>
      <description>

&lt;h2 id=&#34;run-vs-cmd-vs-entrypoint&#34;&gt;run-vs-cmd-vs-entrypoint&lt;/h2&gt;

&lt;p&gt;首先明确一下概念:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;run:执行命令并创建新的 image layer
cmd:设置容器启动后默认执行的命令和参数
entrypoint:设置容器启动时运行的命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在介绍cmd和entrypoint之前,先了解一下shell和exec格式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos
RUN apt-get install -y vim
ENV name docker
CMD echo &amp;quot;hello docker&amp;quot;
ENTRYPOINT echo &amp;quot;hello $name &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exec&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos  
RUN [&amp;quot;apt-get&amp;quot;, &amp;quot;install&amp;quot;, &amp;quot;-y&amp;quot;, &amp;quot;vim&amp;quot;]
ENV name docker
CMD [&amp;quot;/bin/echo&amp;quot;, &amp;quot;hello docker&amp;quot;]
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,  &amp;quot;echo hello $name &amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;build一个docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd somefile
docker build -t cc/xxx .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmd&#34;&gt;CMD&lt;/h2&gt;

&lt;p&gt;容器启动时默认执行的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos
ENV name docker
CMD echo &amp;quot;hello $name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;情况一：如果docker run指定了其它命令，CMD命令被忽略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -it [image] /bin/bsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;情况二：如果定义了多个CMD，只有最后一个执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;...
CMD echo &amp;quot;hello ab&amp;quot;
CMD echo &amp;quot;hello $name&amp;quot;  # 只执行这个
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;entrypoint&#34;&gt;ENTRYPOINT&lt;/h2&gt;

&lt;p&gt;让容器以应用程序或者服务的形式运行
特点：不会被忽略，一定执行
最佳实践：写一个shell脚本作为entrypoint&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;COPY docker-entrypoint.sh /usr/local/bin
ENTRYPOINT [&amp;quot;docker-entrypoint.sh&amp;quot;]
EXPOSE 27017
CMD [&amp;quot;mongoDB&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_6</title>
      <link>https://ouchaochao.github.io/post/docker2_6/</link>
      <pubDate>Sun, 18 Aug 2019 20:11:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_6/</guid>
      <description>

&lt;h2 id=&#34;dockerfile语法梳理&#34;&gt;dockerfile语法梳理&lt;/h2&gt;

&lt;h3 id=&#34;from-从哪里构建image&#34;&gt;FROM：从哪里构建image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM scratch # 制作base image
FROM centos # 使用base image
FROM ubuntu:18.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：为了安全，请使用官方的image&lt;/p&gt;

&lt;h3 id=&#34;label-标签&#34;&gt;LABEL：标签&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LABEL maintainer=&amp;quot;abc@gmail.com&amp;quot;
LABEL version=&amp;quot;1.1&amp;quot;
LABEL description=&amp;quot;This is description&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：Metadata不可少！&lt;/p&gt;

&lt;h3 id=&#34;run&#34;&gt;RUN&lt;/h3&gt;

&lt;p&gt;为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;RUN yum update &amp;amp;&amp;amp; yum install -y vim \
    python-dev # 反斜线换行
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y perl\
    pwgen --no-install-recommends &amp;amp;&amp;amp; rm -rf \
    /var/lib/apt/list/* # 注意清理cache
RUN /bin/bash -c &#39;source $HOME/.bashrc; echo
    $HOME&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;workdir-设定当前工作目录&#34;&gt;WORKDIR：设定当前工作目录&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
WORKDIR /test # 如果没有，会自动创建的
WORKDIR demo
RUN pwd # 输出结果应该是 /test/demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：不要用RUN cd代替WORKDIR，尽量使用绝对目录&lt;/p&gt;

&lt;h3 id=&#34;add和copy&#34;&gt;ADD和COPY&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ADD hello /
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ADD test.tar.gz # 添加到根目录并解压
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
ADD hello test # /root/test/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
COPY hello test # /root/test/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分情况copy优于add
add除了copy功能外，还附带解压缩
添加远程文件/目录请使用curl或者wget&lt;/p&gt;

&lt;h3 id=&#34;env-定义常量&#34;&gt;ENV 定义常量&lt;/h3&gt;

&lt;p&gt;env可增加可维护性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ENV MYSQL_VERSION 5.6
RUN apt-get install -y mysql-server= &amp;quot;${MYSQL_VERSION}&amp;quot; \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* # 引用常量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/docker-library/mysql/blob/master/5.6/Dockerfile&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Dockerfile Demo Time&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_5</title>
      <link>https://ouchaochao.github.io/post/docker2_5/</link>
      <pubDate>Sun, 18 Aug 2019 20:09:45 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_5/</guid>
      <description>

&lt;h2 id=&#34;构建自己的docker镜像&#34;&gt;构建自己的Docker镜像&lt;/h2&gt;

&lt;h3 id=&#34;把一个container-commit成自己的&#34;&gt;把一个Container commit成自己的&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -it centos
$ yum install -y vim
$ docker commit container_name cc/centos-vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用dockerfile构建-推荐&#34;&gt;用dockerfile构建（推荐）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir centos-vim 
$ cd centos-vim
$ vim Dockerfile

FROM centos
RUN yum install -y vim # 思考为什么image只读却可以写

$ docker build -t cc/centos-vim .
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_4</title>
      <link>https://ouchaochao.github.io/post/docker2_4/</link>
      <pubDate>Sun, 18 Aug 2019 20:09:02 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_4/</guid>
      <description>

&lt;h2 id=&#34;初识container系统&#34;&gt;初识Container系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过Image创建（copy）&lt;/li&gt;
&lt;li&gt;在Image layer之上建立一个container layer（可读写）&lt;/li&gt;
&lt;li&gt;类比面向对象：类和实例&lt;/li&gt;
&lt;li&gt;Image负责app的存储和分发，Container负责运行app&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_4_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker交互 -it
docker run -it centos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-的一些命令&#34;&gt;Docker 的一些命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker --help
docker container --help
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_3</title>
      <link>https://ouchaochao.github.io/post/docker2_3/</link>
      <pubDate>Sun, 18 Aug 2019 20:07:02 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_3/</guid>
      <description>

&lt;h2 id=&#34;diy-base-image&#34;&gt;DIY-Base-Image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 将docker加入管理员，以后使用docker不用再加sudo
$ sudo groupadd docker
$ sudo gpasswd -a username docker
# 完成后重启命令行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来建立自己的docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir halo
$ cd halo
$ vim halo.c

#include&amp;lt;stdio.h&amp;gt;
int main()
{
printf(&amp;quot;halo done!\n&amp;quot;);
}

$ gcc -static halo.c -o halo
$ vim Dockerfile

FROM scratch
ADD halo /
CMD [&amp;quot;/halo&amp;quot;]

$ docker build -t cc/halo .
$ docker run cc/halo
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_2</title>
      <link>https://ouchaochao.github.io/post/docker2_2/</link>
      <pubDate>Sun, 18 Aug 2019 20:06:16 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_2/</guid>
      <description>

&lt;h2 id=&#34;什么是image&#34;&gt;什么是Image&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件和meta data的集合（root file system）&lt;/li&gt;
&lt;li&gt;分层的， 并且每一层都可以添加改变删除文件成为一个新的image&lt;/li&gt;
&lt;li&gt;不同的image可以共享相同的layer&lt;/li&gt;
&lt;li&gt;Image本身是read-only&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_2_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;image的获取&#34;&gt;Image的获取&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Build from Dockerfile&lt;/li&gt;
&lt;li&gt;Pull from Registry&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_1</title>
      <link>https://ouchaochao.github.io/post/docker2_1/</link>
      <pubDate>Sun, 18 Aug 2019 20:05:28 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_1/</guid>
      <description>

&lt;h2 id=&#34;docker架构和底层技术简介系统学习&#34;&gt;Docker架构和底层技术简介系统学习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker提供一个开发、打包、运行app的平台&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把app和底层infrastructure隔离开&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker engine&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;后台进程（dockerd）&lt;/li&gt;
&lt;li&gt;REST API Server&lt;/li&gt;
&lt;li&gt;CLI接口（docker）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker architecture&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_3.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;底层技术支持&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;namespaces: 做隔离pid, net, ipc, mnt, uts&lt;/li&gt;
&lt;li&gt;control groups: 做资源限制&lt;/li&gt;
&lt;li&gt;union file systems: container 和 image的分层&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念1</title>
      <link>https://ouchaochao.github.io/post/docker1/</link>
      <pubDate>Sun, 18 Aug 2019 20:04:20 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker1/</guid>
      <description>

&lt;h2 id=&#34;docker是什么&#34;&gt;docker是什么&lt;/h2&gt;

&lt;p&gt;Docker 是一个&lt;a href=&#34;https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;开源&lt;/a&gt;的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 &lt;a href=&#34;https://baike.baidu.com/item/Linux&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;或Windows 机器上，也可以实现&lt;a href=&#34;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;虚拟化&lt;/a&gt;。容器是完全使用&lt;a href=&#34;https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;沙箱&lt;/a&gt;机制，相互之间不会有任何接口。&lt;/p&gt;

&lt;p&gt;说人话就是，docker把环境封装成一个集装箱，集装箱之间的环境（如python2/3）不会相互干扰。&lt;/p&gt;

&lt;h2 id=&#34;安装docker&#34;&gt;安装docker&lt;/h2&gt;

&lt;p&gt;请对应自己的系统点击以下链接进行安装：
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;centos&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;debain&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/fedora/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;fedora&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ubuntu&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/docker-for-mac/install/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;mac&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/docker-for-windows/install/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;windows&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自动部署hugo脚本</title>
      <link>https://ouchaochao.github.io/post/develophugo/</link>
      <pubDate>Sun, 18 Aug 2019 19:09:42 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/develophugo/</guid>
      <description>&lt;p&gt;写完markdowm再输入手动命令行进行部署hugo太费事了，于是就写了这个脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh

function list(){
  echo &amp;quot;查询到有以下md文件:&amp;quot;
  cd content/post/
  ls
  cd ../../
}

function add(){
  echo &amp;quot;请输入文章的题目：&amp;quot;
  read input
  hugo new post/$input.md
  echo &amp;quot;&amp;quot;
  echo &amp;quot;Add $input done!&amp;quot;
}

function deploy(){
  hugo
  cd public
  git add .
  git commit -m &amp;quot;add $input&amp;quot;
  git push origin master
  echo &amp;quot;&amp;quot;
  echo &amp;quot;Deploy done!&amp;quot;
}

function change(){
  list
  echo &amp;quot;请输入要修改的文章题目：&amp;quot;
  read input    
  vim content/post/$input.md
  hugo
  cd public
  git add .
  git commit -m &amp;quot;change $input&amp;quot;
  git push origin master
  echo &amp;quot;&amp;quot;
  echo &amp;quot;Change $input done!&amp;quot;
}

function del(){
  list
  echo &amp;quot;请输入要删除的文章题目：&amp;quot;
  read input    
  rm content/post/$input.md
  hugo
  cd public
  git add .
  git commit -m &amp;quot;del $input&amp;quot;
  git push origin master
  echo &amp;quot;&amp;quot;
  echo &amp;quot;Del $input done!&amp;quot;
}

echo &amp;quot;请输入序号：&amp;quot;
echo &amp;quot;    1.新建post&amp;quot;
echo &amp;quot;    2.修改post&amp;quot;
echo &amp;quot;    3.删除post&amp;quot;
echo &amp;quot;    4.部署&amp;quot;
echo &amp;quot;    5.退出&amp;quot;
read b

if (( $b==1 ));then
	add
elif (( $b==2 ));then
	change
elif (( $b==3 ));then
	del
elif (( $b==4 ));then
	deploy
else
	echo &amp;quot;退出成功&amp;quot;
fi


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;myblog
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── new.sh
├── public
├── resources
├── static
└── themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我把它放在了myblog文件夹下，命名为new.sh，然后输入&lt;code&gt;chmod +x new.sh&lt;/code&gt;赋予权限，当我要新建/修改/删除博客的时候就只要输入&lt;code&gt;./new.sh&lt;/code&gt;就行了，下面是操作示例：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;新建&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;myblog ./new.sh
./new.sh: line 2: input: command not found
请输入序号：
	1.新建post
	2.修改post
	3.删除post
	4.退出
1
请输入文章的题目：
test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着就是在vim中编辑Markdown文件了，保存退出后会自动部署到github上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/Users/ouchaochao/myblog/content/post/test.md created
Building sites … WARN 2019/08/18 19:16:54 Page&#39;s .URL is deprecated and will be removed in a future release. Use .Permalink or .RelPermalink. If what you want is the front matter URL value, use .Params.url.
WARN 2019/08/18 19:16:54 Page&#39;s .RSSLink is deprecated and will be removed in a future release. Use the Output Format&#39;s link, e.g. something like: 
    {{ with .OutputFormats.Get &amp;quot;RSS&amp;quot; }}{{ .RelPermalink }}{{ end }}.
WARN 2019/08/18 19:16:54 Page&#39;s .Hugo is deprecated and will be removed in a future release. Use the global hugo function.

                   | EN  
+------------------+----+
  Pages            | 19  
  Paginator pages  |  2  
  Non-page files   |  0  
  Static files     | 28  
  Processed images |  0  
  Aliases          |  6  
  Sitemaps         |  1  
  Cleaned          |  0  

Total in 15 ms
[master 364f578] add test
 12 files changed, 1274 insertions(+), 108 deletions(-)
 create mode 100644 &amp;quot;2019/08/18/\350\207\252\345\212\250\351\203\250\347\275\262hugo\350\204\232\346\234\254/index.html&amp;quot;
 create mode 100644 page/2/index.html
 create mode 100644 post/page/2/index.html
枚举对象: 45, 完成.
对象计数中: 100% (45/45), 完成.
使用 6 个线程进行压缩
压缩对象中: 100% (19/19), 完成.
写入对象中: 100% (26/26), 6.20 KiB | 6.20 MiB/s, 完成.
总共 26 （差异 13），复用 0 （差异 0）
remote: Resolving deltas: 100% (13/13), completed with 8 local objects.
To https://github.com/ouchaochao/ouchaochao.github.io.git
   fa466d6..364f578  master -&amp;gt; master

Add test done!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它的操作同理，在此就不一一赘述了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_7</title>
      <link>https://ouchaochao.github.io/post/go3_7/</link>
      <pubDate>Fri, 09 Aug 2019 09:21:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_7/</guid>
      <description>

&lt;h2 id=&#34;api数据库层设计&#34;&gt;api数据库层设计&lt;/h2&gt;

&lt;h3 id=&#34;数据库设计-用户&#34;&gt;数据库设计: 用户&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;users&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;UNSIGNED INT&lt;br&gt;PRIMARY KEY&lt;br&gt;AUTO_INCREMENT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用户不可见&lt;br&gt;主键&lt;br&gt;自动增量更新&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;login_name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;br&gt;UNIQUE KEY&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;br&gt;用户名不能重复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;pwd&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;数据库设计-视频资源&#34;&gt;数据库设计: 视频资源&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;video_info&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;br&gt;PRIMARY KEY&lt;br&gt;NOT NULL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;资源多,要长&lt;br&gt;主键&lt;br&gt;不为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;author_id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;UNSIGNED INT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上传视频的用户id&lt;br&gt;起到外键作用, 但是是在代码逻辑中处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;display_ctime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;展示给用户看&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;create_time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DATETIME&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用户理解会有困难, 所以创建display_ctime&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;数据库设计-评论&#34;&gt;数据库设计: 评论&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;comments&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;br&gt;PRIMARY KEY&lt;br&gt;NOT NULL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;br&gt;-&lt;br&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;video_id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;视频的id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;author_id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;UNSIGNED INT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上传视频的用户id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;content&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DATETIME&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;数据库设计-sessions&#34;&gt;数据库设计: sessions&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;sessions&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TINYTEXT&lt;br&gt;PRIMARY KEY&lt;br&gt;NOT NULL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用户登录是无限次的, 所以要非常大的数字&lt;br&gt;-&lt;br&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;TTL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TINYTEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Time To Live: 过期时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;login_name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;四张表的关系&#34;&gt;四张表的关系&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/3_7_1.png&#34; alt=&#34;&#34; /&gt;
接下来在mysql中创建对应的表格即可:
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/3_7_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>