<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeaveIt on LeaveIt</title>
    <link>https://ouchaochao.github.io/</link>
    <description>Recent content in LeaveIt on LeaveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 20 Aug 2019 22:52:15 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go3_15to3_16</title>
      <link>https://ouchaochao.github.io/post/go3_15to3_16/</link>
      <pubDate>Tue, 20 Aug 2019 22:52:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_15to3_16/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_8至3_14</title>
      <link>https://ouchaochao.github.io/post/go3_8to3_14/</link>
      <pubDate>Tue, 20 Aug 2019 22:07:19 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_8to3_14/</guid>
      <description>

&lt;h2 id=&#34;数据库连接&#34;&gt;数据库连接&lt;/h2&gt;

&lt;p&gt;首先先下载数据库连接工具：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go get github.com/go-sql-driver/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;dbops&lt;/code&gt;文件夹中新建三个文件，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dbops
├── api.go
├── api_test.go  // 测试api
└── conn.go  // 连接数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看看mysql数据库的连接：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//conn.go
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

var (
	dbConn *sql.DB
	err error
)

func init()  {
	// 复用dbConn
	dbConn, err = sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:1@tcp(47.94.131.35:3306)/video?charset=utf8&amp;quot;)
	if err != nil{
		// 无法连接时抛出异常
		panic(err.Error())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接完数据库，接下来就是对数据库的增删改查了，下面分别按&lt;code&gt;用户&lt;/code&gt;，&lt;code&gt;视频&lt;/code&gt;，&lt;code&gt;评论&lt;/code&gt;这三个模块来展示怎么写代码和测试：&lt;/p&gt;

&lt;h2 id=&#34;用户&#34;&gt;用户&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;用户&lt;/code&gt;模块有三个功能，分别是增加、查询和删除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
package dbops

import (
	&amp;quot;database/sql&amp;quot;
	_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;video/api/defs&amp;quot;
	&amp;quot;video/api/utils&amp;quot;
)

/*
下面三个函数分别是：
	添加用户
	获取用户信息
	删除用户
*/
func AddUserCredential(loginName string, pwd string) error {
	// 千万不要用+号来连接query的各个部分, 不安全, 容易被撞库攻击
	//Prepare预编译, 更安全了, 会拦下撞库攻击
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO users (login_name, pwd) VALUES (?, ?)&amp;quot;)
	if err != nil {
		return err
	}
	// 执行, 将两个参数传到上面两个问号处
	_, err = stmtIns.Exec(loginName, pwd)
	if err != nil {
		return err
	}
	// defer 是栈退出的时候才调用, 性能会有些许损耗
	defer stmtIns.Close()
	return nil
}

func GetUserCredential(loginName string) (string, error) {
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT pwd FROM users WHERE login_name = ?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;%s&amp;quot;, err)
		// string 默认是没有内容的
		return &amp;quot;&amp;quot;, err
	}

	var pwd string
	err = stmtOut.QueryRow(loginName).Scan(&amp;amp;pwd)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return &amp;quot;&amp;quot;, err
	}
	defer stmtOut.Close()
	return pwd, nil
}

func DeleteUser(loginName string, pwd string) error {
	stmtDel, err := dbConn.Prepare(&amp;quot;DELETE FROM users WHERE login_name=? AND pwd=?&amp;quot;)
	if err != nil {
		log.Printf(&amp;quot;DeleteUser error: %s&amp;quot;, err)
		return err
	}
	_, err = stmtDel.Exec(loginName, pwd)
	if err != nil {
		return err
	}

	stmtDel.Close()
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;包含对添加、查询和修改的代码，其中多了一个Reget函数，是为了测试删除函数是否起到作用而存在的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
package dbops

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;testing&amp;quot;
	&amp;quot;time&amp;quot;
)

var tempvid string

func clearTables() {
	// 初始化, 保证数据库每次都是新的
	dbConn.Exec(&amp;quot;truncate users&amp;quot;)
	dbConn.Exec(&amp;quot;truncate video_info&amp;quot;)
	dbConn.Exec(&amp;quot;truncate comments&amp;quot;)
	dbConn.Exec(&amp;quot;truncate sessions&amp;quot;)
}

func TestMain(m *testing.M) {
	clearTables()
	m.Run()
	clearTables()
}

/*
测试有关用户的函数
*/
func TestUserWorkFlow(t *testing.T) {
	t.Run(&amp;quot;Add&amp;quot;, testAddUser)
	t.Run(&amp;quot;Get&amp;quot;, testGetUser)
	t.Run(&amp;quot;Del&amp;quot;, testDeleteUser)
	t.Run(&amp;quot;Reget&amp;quot;, testRegetUser)
}

func testAddUser(t *testing.T) {
	err := AddUserCredential(&amp;quot;leo&amp;quot;, &amp;quot;123&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error of AddUser: %v&amp;quot;, err)
	}
}

func testGetUser(t *testing.T) {
	pwd, err := GetUserCredential(&amp;quot;leo&amp;quot;)
	if pwd != &amp;quot;123&amp;quot; || err != nil {
		t.Errorf(&amp;quot;Error get user&amp;quot;)
	}
}

func testDeleteUser(t *testing.T) {
	err := DeleteUser(&amp;quot;leo&amp;quot;, &amp;quot;123&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error delete user: %v&amp;quot;, err)
	}
}

func testRegetUser(t *testing.T) {
	pwd, err := GetUserCredential(&amp;quot;leo&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error of reget user: %v&amp;quot;, err)
	}
	if pwd != &amp;quot;&amp;quot; {
		t.Errorf(&amp;quot;Delete user test failed&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;视频&lt;/code&gt;包含了增加、查询和删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
/*
下面三个函数分别是：
	添加视频
	获取视频
	删除视频
*/
func AddVideoInfo(aid int, name string) (*defs.VideoInfo, error) {
	//Create uuid
	vid, err := utils.NewUUID()
	if err != nil {
		return nil, err
	}
	t := time.Now()
	// 时间格式, go的彩蛋
	ctime := t.Format(&amp;quot;Jan 02 2006, 15:04:05&amp;quot;)
	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO video_info (id, author_id, name, display_ctime) VALUES (?,?,?,?)&amp;quot;)
	if err != nil {
		return nil, err
	}

	_, err = stmtIns.Exec(vid, aid, name, ctime)
	if err != nil {
		return nil, err
	}
	res := &amp;amp;defs.VideoInfo{Id: vid, AuthorId: aid, Name: name, DisplayCtime: ctime}
	defer stmtIns.Close()
	//怎么测试：res.XX
	return res, nil
}

func GetVideoInfo(vid string) (*defs.VideoInfo, error) {
	stmtOut, err := dbConn.Prepare(&amp;quot;SELECT author_id, name, display_ctime FROM video_info WHERE id=?&amp;quot;)

	//var不能写在一起
	var aid int
	var dct string
	var name string

	err = stmtOut.QueryRow(vid).Scan(&amp;amp;aid, &amp;amp;name, &amp;amp;dct)
	if err != nil &amp;amp;&amp;amp; err != sql.ErrNoRows {
		return nil, err
	}

	if err == sql.ErrNoRows {
		return nil, nil
	}

	defer stmtOut.Close()
	res := &amp;amp;defs.VideoInfo{Id: vid, AuthorId: aid, Name: name, DisplayCtime: dct}
	return res, nil
}

func DeleteVideoInfo(vid string) error {
	stmtDel, err := dbConn.Prepare(&amp;quot;DELETE FROM video_info WHERE id=?&amp;quot;)
	if err != nil {
		return err
	}
	_, err = stmtDel.Exec(vid)
	if err != nil {
		return nil
	}
	defer stmtDel.Close()
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
/*
测试有关视频的函数，值得注意的是，添加视频前必须要有用户存在
*/
func TestVideoWorkFlow(t *testing.T) {
	clearTables()
	t.Run(&amp;quot;PrepareUser&amp;quot;, testAddUser)
	t.Run(&amp;quot;AddVideo&amp;quot;, testAddVideoInfo)
	t.Run(&amp;quot;GetVideo&amp;quot;, testGetVideoInfo)
	t.Run(&amp;quot;DelVideo&amp;quot;, testDeleteVideoInfo)
	t.Run(&amp;quot;RegetVideo&amp;quot;, testRegetVideoInfo)
}

func testAddVideoInfo(t *testing.T) {
	vi, err := AddVideoInfo(1, &amp;quot;my_video&amp;quot;)
	if err != nil {
		t.Errorf(&amp;quot;Error add video: %v&amp;quot;, err)
	}
	tempvid = vi.Id
}

func testGetVideoInfo(t *testing.T) {
	_, err := GetVideoInfo(tempvid)
	if err != nil {
		t.Errorf(&amp;quot;Error get video: %v&amp;quot;, err)
	}
}

func testDeleteVideoInfo(t *testing.T) {
	err := DeleteVideoInfo(tempvid)
	if err != nil {
		t.Errorf(&amp;quot;Error del video:%v&amp;quot;, err)
	}
}
func testRegetVideoInfo(t *testing.T) {
	vi, err := GetVideoInfo(tempvid)
	if err != nil || vi != nil {
		t.Errorf(&amp;quot;Error reget video: %v&amp;quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;评论&#34;&gt;评论&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;评论&lt;/code&gt;包含了添加和查询，没有删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api.go
/*
下面两个函数分别是：
	添加评论
	查看评论
	此处不添加删除评论
*/
func AddComments(vid string, aid int, content string) error {
	id, err := utils.NewUUID()
	if err != nil {
		return err
	}

	stmtIns, err := dbConn.Prepare(&amp;quot;INSERT INTO comments (id, video_id, author_id, content) VALUES (?,?,?,?)&amp;quot;)
	if err != nil {
		return err
	}

	_, err = stmtIns.Exec(id, vid, aid, content)
	if err != nil {
		return nil
	}
	defer stmtIns.Close()
	return nil
}

func ListComments(vid string, from, to int) ([]*defs.Comment, error) {
	// 连接user和comments表查询字段
	stmtOut, err := dbConn.Prepare(`SELECT comments.id, users.Login_name, comments.content FROM comments
		INNER JOIN users ON comments.author_id=users.id
		WHERE comments.video_id=? AND comments.time &amp;gt; FROM_UNIXTIME(?) AND comments.time &amp;lt;= FROM_UNIXTIME(?)`)

	//此处定义了Comment，放在了apidef.go文件中
	var res []*defs.Comment

	rows, err := stmtOut.Query(vid, from, to)
	if err != nil {
		return res, err
	}

	for rows.Next() {
		var id, name, content string
		if err := rows.Scan(&amp;amp;id, &amp;amp;name, &amp;amp;content); err != nil {
			return res, err
		}
		c := &amp;amp;defs.Comment{Id: id, VideoId: vid, Author: name, Content: content}
		res = append(res, c)
	}
	defer stmtOut.Close()
	return res, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附带一下定义了的结构体：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//apidef.go
package defs

type UserCredential struct {
	Username string `json:&amp;quot;username&amp;quot;`
	Pwd      string `json:&amp;quot;pwd&amp;quot;`
}

//Data model
type VideoInfo struct {
	Id           string
	AuthorId     int
	Name         string
	DisplayCtime string
}

type Comment struct {
	Id      string
	VideoId string
	Author  string
	Content string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;测试&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//api_test.go
/*
测试有关评论的函数
*/
func TestComments(t *testing.T) {
	clearTables()
	t.Run(&amp;quot;AddUser&amp;quot;, testAddUser)
	t.Run(&amp;quot;AddComments&amp;quot;, testAddComments)
	t.Run(&amp;quot;ListComments&amp;quot;, testListComments)
}

func testAddComments(t *testing.T) {
	vid := &amp;quot;12345&amp;quot;
	aid := 1
	content := &amp;quot;test&amp;quot;

	err := AddComments(vid, aid, content)
	if err != nil {
		t.Errorf(&amp;quot;Error add comment: %v&amp;quot;, err)
	}
}

func testListComments(t *testing.T) {
	vid := &amp;quot;12345&amp;quot;
	from := 1514764800
	// 把当前时间转化成, 单位: 纳秒
	to, _ := strconv.Atoi(strconv.FormatInt(time.Now().UnixNano()/1000000000, 10))
	res, err := ListComments(vid, from, to)
	if err != nil {
		t.Errorf(&amp;quot;Error list comments: %v&amp;quot;, err)
	}

	for i, ele := range res {
		fmt.Printf(&amp;quot;comment:%d,%v\n&amp;quot;, i, ele)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总体来说，增删改查的代码很基础，也是重复的工作量，这里没有用到花里胡哨的技能，同时也@一下&lt;a href=&#34;https://github.com/dobio&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;颜威&lt;/a&gt;同学，在他那里学到了一个小技巧，就是每写一个函数就写一个测试函数，保证自己的代码能跑通，也能马上获得正反馈。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go自动化部署项目</title>
      <link>https://ouchaochao.github.io/post/developgo/</link>
      <pubDate>Sun, 18 Aug 2019 20:14:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/developgo/</guid>
      <description>&lt;p&gt;趁着有点时间学了一下&lt;a href=&#34;https://www.imooc.com/learn/910&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;DevOps和云计算初识&lt;/a&gt;, 发现一个以前没想到过的点 &amp;ndash; 自动化部署项目.&lt;/p&gt;

&lt;p&gt;这个项目是用Go写的, 大致的过程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 在本地写完代码之后, git push到github上
2. github里的Webhooks会被触发, 进而会访问一个设定好的网站
3. 这个网站就是DeployServer, 它会从github里git pull你刚push的代码
4. 代码返回到服务器
5. DeployServer停掉旧版本的WebServer, 然后运行最新的Webserver代码
6. 完成更新, 浏览器打开WebServer的网址就能访问最新的网页
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是Webhooks的示意图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是DeployServer的sh文件写法, 仅供参考:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/0_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_8</title>
      <link>https://ouchaochao.github.io/post/docker2_8/</link>
      <pubDate>Sun, 18 Aug 2019 20:13:31 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_8/</guid>
      <description>

&lt;h2 id=&#34;镜像的分布&#34;&gt;镜像的分布&lt;/h2&gt;

&lt;h3 id=&#34;docker-hub&#34;&gt;docker hub&lt;/h3&gt;

&lt;p&gt;首先在终端中登陆账号(账号在docker hub里注册)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是push自己的docker：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一：docker hub&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Usage:  docker push [OPTIONS] NAME[:TAG]
例如：
docker push ouchaochao/hello-world:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法不好的地方就是别人会担心你的docker里有病毒，所以一般使用方法二。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二：dockerfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过关联github和docker hub，我们只要在github上维护dockerfile就行了，docker hub会根据关联的dockerfile自动build好docker仓库。&lt;/p&gt;

&lt;p&gt;下面讲解如何关联github和docker hub：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开account setting:
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;往下找到linked accounts，绑定github
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在github中新建dockerfile项目
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在docker hub中绑定github的dockerfile
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成结果
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;搭建公司-自己的docker-hub&#34;&gt;搭建公司/自己的docker hub&lt;/h3&gt;

&lt;p&gt;docker hub 中搜索registry，linux系统中输入以下代码就完成了部署&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d -p 5000:5000 --restart always --name registry registry:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;怎么push&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;build的改变，把NAME部分换成ip地址，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build -t 47.94.131.35:5000/hello-world . # 换成自己的ip
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看image&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker image ls
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改docker下的daemon.json文件，把服务器添加信任，然后点Apply &amp;amp; Restart
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_8_6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来就是push&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker push 47.94.131.35:5000/hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过在网页打开以下网站查看是否上传成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://47.94.131.35:5000/v2/_catalog

成功的话会有以下输出：
// 20190812013314
// http://47.94.131.35:5000/v2/_catalog

{
&amp;quot;repositories&amp;quot;: [
&amp;quot;hello-world&amp;quot;
]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Registry Api &lt;a href=&#34;https://docs.docker.com/registry/spec/api/#listing-repositories&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;网站&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_7</title>
      <link>https://ouchaochao.github.io/post/docker2_7/</link>
      <pubDate>Sun, 18 Aug 2019 20:12:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_7/</guid>
      <description>

&lt;h2 id=&#34;run-vs-cmd-vs-entrypoint&#34;&gt;run-vs-cmd-vs-entrypoint&lt;/h2&gt;

&lt;p&gt;首先明确一下概念:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;run:执行命令并创建新的 image layer
cmd:设置容器启动后默认执行的命令和参数
entrypoint:设置容器启动时运行的命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在介绍cmd和entrypoint之前,先了解一下shell和exec格式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos
RUN apt-get install -y vim
ENV name docker
CMD echo &amp;quot;hello docker&amp;quot;
ENTRYPOINT echo &amp;quot;hello $name &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;exec&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos  
RUN [&amp;quot;apt-get&amp;quot;, &amp;quot;install&amp;quot;, &amp;quot;-y&amp;quot;, &amp;quot;vim&amp;quot;]
ENV name docker
CMD [&amp;quot;/bin/echo&amp;quot;, &amp;quot;hello docker&amp;quot;]
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,  &amp;quot;echo hello $name &amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;build一个docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd somefile
docker build -t cc/xxx .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cmd&#34;&gt;CMD&lt;/h2&gt;

&lt;p&gt;容器启动时默认执行的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM centos
ENV name docker
CMD echo &amp;quot;hello $name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;情况一：如果docker run指定了其它命令，CMD命令被忽略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -it [image] /bin/bsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;情况二：如果定义了多个CMD，只有最后一个执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;...
CMD echo &amp;quot;hello ab&amp;quot;
CMD echo &amp;quot;hello $name&amp;quot;  # 只执行这个
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;entrypoint&#34;&gt;ENTRYPOINT&lt;/h2&gt;

&lt;p&gt;让容器以应用程序或者服务的形式运行
特点：不会被忽略，一定执行
最佳实践：写一个shell脚本作为entrypoint&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;COPY docker-entrypoint.sh /usr/local/bin
ENTRYPOINT [&amp;quot;docker-entrypoint.sh&amp;quot;]
EXPOSE 27017
CMD [&amp;quot;mongoDB&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_6</title>
      <link>https://ouchaochao.github.io/post/docker2_6/</link>
      <pubDate>Sun, 18 Aug 2019 20:11:15 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_6/</guid>
      <description>

&lt;h2 id=&#34;dockerfile语法梳理&#34;&gt;dockerfile语法梳理&lt;/h2&gt;

&lt;h3 id=&#34;from-从哪里构建image&#34;&gt;FROM：从哪里构建image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FROM scratch # 制作base image
FROM centos # 使用base image
FROM ubuntu:18.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：为了安全，请使用官方的image&lt;/p&gt;

&lt;h3 id=&#34;label-标签&#34;&gt;LABEL：标签&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LABEL maintainer=&amp;quot;abc@gmail.com&amp;quot;
LABEL version=&amp;quot;1.1&amp;quot;
LABEL description=&amp;quot;This is description&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：Metadata不可少！&lt;/p&gt;

&lt;h3 id=&#34;run&#34;&gt;RUN&lt;/h3&gt;

&lt;p&gt;为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;RUN yum update &amp;amp;&amp;amp; yum install -y vim \
    python-dev # 反斜线换行
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y perl\
    pwgen --no-install-recommends &amp;amp;&amp;amp; rm -rf \
    /var/lib/apt/list/* # 注意清理cache
RUN /bin/bash -c &#39;source $HOME/.bashrc; echo
    $HOME&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;workdir-设定当前工作目录&#34;&gt;WORKDIR：设定当前工作目录&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
WORKDIR /test # 如果没有，会自动创建的
WORKDIR demo
RUN pwd # 输出结果应该是 /test/demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：不要用RUN cd代替WORKDIR，尽量使用绝对目录&lt;/p&gt;

&lt;h3 id=&#34;add和copy&#34;&gt;ADD和COPY&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ADD hello /
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ADD test.tar.gz # 添加到根目录并解压
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
ADD hello test # /root/test/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;WORKDIR /root
COPY hello test # /root/test/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大部分情况copy优于add
add除了copy功能外，还附带解压缩
添加远程文件/目录请使用curl或者wget&lt;/p&gt;

&lt;h3 id=&#34;env-定义常量&#34;&gt;ENV 定义常量&lt;/h3&gt;

&lt;p&gt;env可增加可维护性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ENV MYSQL_VERSION 5.6
RUN apt-get install -y mysql-server= &amp;quot;${MYSQL_VERSION}&amp;quot; \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* # 引用常量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/docker-library/mysql/blob/master/5.6/Dockerfile&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Dockerfile Demo Time&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_5</title>
      <link>https://ouchaochao.github.io/post/docker2_5/</link>
      <pubDate>Sun, 18 Aug 2019 20:09:45 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_5/</guid>
      <description>

&lt;h2 id=&#34;构建自己的docker镜像&#34;&gt;构建自己的Docker镜像&lt;/h2&gt;

&lt;h3 id=&#34;把一个container-commit成自己的&#34;&gt;把一个Container commit成自己的&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -it centos
$ yum install -y vim
$ docker commit container_name cc/centos-vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用dockerfile构建-推荐&#34;&gt;用dockerfile构建（推荐）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir centos-vim 
$ cd centos-vim
$ vim Dockerfile

FROM centos
RUN yum install -y vim # 思考为什么image只读却可以写

$ docker build -t cc/centos-vim .
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_4</title>
      <link>https://ouchaochao.github.io/post/docker2_4/</link>
      <pubDate>Sun, 18 Aug 2019 20:09:02 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_4/</guid>
      <description>

&lt;h2 id=&#34;初识container系统&#34;&gt;初识Container系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过Image创建（copy）&lt;/li&gt;
&lt;li&gt;在Image layer之上建立一个container layer（可读写）&lt;/li&gt;
&lt;li&gt;类比面向对象：类和实例&lt;/li&gt;
&lt;li&gt;Image负责app的存储和分发，Container负责运行app&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_4_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker交互 -it
docker run -it centos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-的一些命令&#34;&gt;Docker 的一些命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker --help
docker container --help
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_3</title>
      <link>https://ouchaochao.github.io/post/docker2_3/</link>
      <pubDate>Sun, 18 Aug 2019 20:07:02 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_3/</guid>
      <description>

&lt;h2 id=&#34;diy-base-image&#34;&gt;DIY-Base-Image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 将docker加入管理员，以后使用docker不用再加sudo
$ sudo groupadd docker
$ sudo gpasswd -a username docker
# 完成后重启命令行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来建立自己的docker&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir halo
$ cd halo
$ vim halo.c

#include&amp;lt;stdio.h&amp;gt;
int main()
{
printf(&amp;quot;halo done!\n&amp;quot;);
}

$ gcc -static halo.c -o halo
$ vim Dockerfile

FROM scratch
ADD halo /
CMD [&amp;quot;/halo&amp;quot;]

$ docker build -t cc/halo .
$ docker run cc/halo
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_2</title>
      <link>https://ouchaochao.github.io/post/docker2_2/</link>
      <pubDate>Sun, 18 Aug 2019 20:06:16 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_2/</guid>
      <description>

&lt;h2 id=&#34;什么是image&#34;&gt;什么是Image&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件和meta data的集合（root file system）&lt;/li&gt;
&lt;li&gt;分层的， 并且每一层都可以添加改变删除文件成为一个新的image&lt;/li&gt;
&lt;li&gt;不同的image可以共享相同的layer&lt;/li&gt;
&lt;li&gt;Image本身是read-only&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_2_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;image的获取&#34;&gt;Image的获取&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Build from Dockerfile&lt;/li&gt;
&lt;li&gt;Pull from Registry&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念2_1</title>
      <link>https://ouchaochao.github.io/post/docker2_1/</link>
      <pubDate>Sun, 18 Aug 2019 20:05:28 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker2_1/</guid>
      <description>

&lt;h2 id=&#34;docker架构和底层技术简介系统学习&#34;&gt;Docker架构和底层技术简介系统学习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker提供一个开发、打包、运行app的平台&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把app和底层infrastructure隔离开&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker engine&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;后台进程（dockerd）&lt;/li&gt;
&lt;li&gt;REST API Server&lt;/li&gt;
&lt;li&gt;CLI接口（docker）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker architecture&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/docker/2_1_3.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;底层技术支持&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;namespaces: 做隔离pid, net, ipc, mnt, uts&lt;/li&gt;
&lt;li&gt;control groups: 做资源限制&lt;/li&gt;
&lt;li&gt;union file systems: container 和 image的分层&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统学习Docker践行DevOps理念1</title>
      <link>https://ouchaochao.github.io/post/docker1/</link>
      <pubDate>Sun, 18 Aug 2019 20:04:20 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/docker1/</guid>
      <description>

&lt;h2 id=&#34;docker是什么&#34;&gt;docker是什么&lt;/h2&gt;

&lt;p&gt;Docker 是一个&lt;a href=&#34;https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;开源&lt;/a&gt;的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 &lt;a href=&#34;https://baike.baidu.com/item/Linux&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;或Windows 机器上，也可以实现&lt;a href=&#34;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;虚拟化&lt;/a&gt;。容器是完全使用&lt;a href=&#34;https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;沙箱&lt;/a&gt;机制，相互之间不会有任何接口。&lt;/p&gt;

&lt;p&gt;说人话就是，docker把环境封装成一个集装箱，集装箱之间的环境（如python2/3）不会相互干扰。&lt;/p&gt;

&lt;h2 id=&#34;安装docker&#34;&gt;安装docker&lt;/h2&gt;

&lt;p&gt;请对应自己的系统点击以下链接进行安装：
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;centos&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/debian/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;debain&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/fedora/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;fedora&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ubuntu&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/docker-for-mac/install/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;mac&lt;/a&gt;
&lt;a href=&#34;https://docs.docker.com/docker-for-windows/install/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;windows&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自动部署hugo脚本</title>
      <link>https://ouchaochao.github.io/post/develophugo/</link>
      <pubDate>Sun, 18 Aug 2019 19:09:42 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/develophugo/</guid>
      <description>&lt;p&gt;写完markdowm再输入手动命令行进行部署hugo太费事了，于是就写了这个脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh
input = &amp;quot;&amp;quot;

function list(){
echo &amp;quot;查询到有以下md文件:&amp;quot;
cd content/post/
ls
cd ../../
}

function add(){
echo &amp;quot;请输入文章的题目：&amp;quot;
read input
hugo new post/$input.md
vim content/post/$input.md
hugo
cd public
git add .
git commit -m &amp;quot;add $input&amp;quot;
git push origin master
echo &amp;quot;&amp;quot;
echo &amp;quot;Add $input done!&amp;quot;
}

function deploy(){
hugo
cd public
git add .
git commit -m &amp;quot;add $input&amp;quot;
git push origin master
echo &amp;quot;&amp;quot;
echo &amp;quot;Deploy done!&amp;quot;
}

function change(){
list
echo &amp;quot;请输入要修改的文章题目：&amp;quot;
read input    
vim content/post/$input.md
hugo
cd public
git add .
git commit -m &amp;quot;change $input&amp;quot;
git push origin master
echo &amp;quot;&amp;quot;
echo &amp;quot;Change $input done!&amp;quot;

}

function del(){
list
echo &amp;quot;请输入要删除的文章题目：&amp;quot;
read input    
rm content/post/$input.md
hugo
cd public
git add .
git commit -m &amp;quot;del $input&amp;quot;
git push origin master
echo &amp;quot;&amp;quot;
echo &amp;quot;Del $input done!&amp;quot;
}

echo &amp;quot;请输入序号：&amp;quot;
echo &amp;quot;    1.新建post&amp;quot;
echo &amp;quot;    2.修改post&amp;quot;
echo &amp;quot;    3.删除post&amp;quot;
echo &amp;quot;    4.部署&amp;quot;
echo &amp;quot;    5.退出&amp;quot;
read b

if (( $b==1 ));then
add
elif (( $b==2 ));then
change
elif (( $b==3 ));then
del
elif (( $b==4 ));then
deploy
else
echo &amp;quot;退出成功&amp;quot;
fi


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;myblog
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── new.sh
├── public
├── resources
├── static
└── themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我把它放在了myblog文件夹下，命名为new.sh，当我要新建/修改/删除博客的时候就只要输入&lt;code&gt;./new.sh&lt;/code&gt;就行了，下面是操作示例：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;新建&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;myblog ./new.sh
./new.sh: line 2: input: command not found
请输入序号：
	1.新建post
	2.修改post
	3.删除post
	4.退出
1
请输入文章的题目：
test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着就是在vim中编辑Markdown文件了，保存退出后会自动部署到github上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/Users/ouchaochao/myblog/content/post/test.md created
Building sites … WARN 2019/08/18 19:16:54 Page&#39;s .URL is deprecated and will be removed in a future release. Use .Permalink or .RelPermalink. If what you want is the front matter URL value, use .Params.url.
WARN 2019/08/18 19:16:54 Page&#39;s .RSSLink is deprecated and will be removed in a future release. Use the Output Format&#39;s link, e.g. something like: 
    {{ with .OutputFormats.Get &amp;quot;RSS&amp;quot; }}{{ .RelPermalink }}{{ end }}.
WARN 2019/08/18 19:16:54 Page&#39;s .Hugo is deprecated and will be removed in a future release. Use the global hugo function.

                   | EN  
+------------------+----+
  Pages            | 19  
  Paginator pages  |  2  
  Non-page files   |  0  
  Static files     | 28  
  Processed images |  0  
  Aliases          |  6  
  Sitemaps         |  1  
  Cleaned          |  0  

Total in 15 ms
[master 364f578] add test
 12 files changed, 1274 insertions(+), 108 deletions(-)
 create mode 100644 &amp;quot;2019/08/18/\350\207\252\345\212\250\351\203\250\347\275\262hugo\350\204\232\346\234\254/index.html&amp;quot;
 create mode 100644 page/2/index.html
 create mode 100644 post/page/2/index.html
枚举对象: 45, 完成.
对象计数中: 100% (45/45), 完成.
使用 6 个线程进行压缩
压缩对象中: 100% (19/19), 完成.
写入对象中: 100% (26/26), 6.20 KiB | 6.20 MiB/s, 完成.
总共 26 （差异 13），复用 0 （差异 0）
remote: Resolving deltas: 100% (13/13), completed with 8 local objects.
To https://github.com/ouchaochao/ouchaochao.github.io.git
   fa466d6..364f578  master -&amp;gt; master

Add test done!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它的操作同理，在此就不一一赘述了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_7</title>
      <link>https://ouchaochao.github.io/post/go3_7/</link>
      <pubDate>Fri, 09 Aug 2019 09:21:36 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_7/</guid>
      <description>

&lt;h2 id=&#34;api数据库层设计&#34;&gt;api数据库层设计&lt;/h2&gt;

&lt;h3 id=&#34;数据库设计-用户&#34;&gt;数据库设计: 用户&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;users&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;UNSIGNED INT&lt;br&gt;PRIMARY KEY&lt;br&gt;AUTO_INCREMENT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用户不可见&lt;br&gt;主键&lt;br&gt;自动增量更新&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;login_name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;br&gt;UNIQUE KEY&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;br&gt;用户名不能重复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;pwd&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;数据库设计-视频资源&#34;&gt;数据库设计: 视频资源&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;video_info&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;br&gt;PRIMARY KEY&lt;br&gt;NOT NULL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;资源多,要长&lt;br&gt;主键&lt;br&gt;不为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;author_id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;UNSIGNED INT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上传视频的用户id&lt;br&gt;起到外键作用, 但是是在代码逻辑中处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;display_ctime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;展示给用户看&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;create_time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DATETIME&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用户理解会有困难, 所以创建display_ctime&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;数据库设计-评论&#34;&gt;数据库设计: 评论&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;comments&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;br&gt;PRIMARY KEY&lt;br&gt;NOT NULL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;br&gt;-&lt;br&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;video_id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;视频的id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;author_id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;UNSIGNED INT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上传视频的用户id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;content&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;time&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DATETIME&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;数据库设计-sessions&#34;&gt;数据库设计: sessions&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;TABLE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;sessions&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;postscript&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;id&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TINYTEXT&lt;br&gt;PRIMARY KEY&lt;br&gt;NOT NULL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用户登录是无限次的, 所以要非常大的数字&lt;br&gt;-&lt;br&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;TTL&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TINYTEXT&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Time To Live: 过期时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;login_name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;VARCHAR(64)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;四张表的关系&#34;&gt;四张表的关系&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/3_7_1.png&#34; alt=&#34;&#34; /&gt;
接下来在mysql中创建对应的表格即可:
&lt;img src=&#34;https://ouchaochao.oss-cn-shenzhen.aliyuncs.com/go/3_7_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言实战流媒体视频网站3_6</title>
      <link>https://ouchaochao.github.io/post/go3_6/</link>
      <pubDate>Thu, 08 Aug 2019 09:04:33 +0800</pubDate>
      
      <guid>https://ouchaochao.github.io/post/go3_6/</guid>
      <description>

&lt;h2 id=&#34;api之http-handler层&#34;&gt;api之http handler层&lt;/h2&gt;

&lt;h3 id=&#34;总览&#34;&gt;总览:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;api
    │  handlers.go
    │  main.go
    │  response.go
    │
    ├─dbops
    │      api.go
    │
    └─defs
            apidef.go
            errs.go

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;流程:&lt;/p&gt;

&lt;p&gt;handler-&amp;gt;validation{1.request, 2.user}-&amp;gt;business logic-&amp;gt;response
1. data model.
2. error handing.&lt;/p&gt;

&lt;p&gt;handler.go会调用dbops, 拿到它想要的东西, 然后做进一步处理, 处理包括消息/信息的定义, 然后将它们一起组装成response, 最后调取response.go, response返回结果到handler.go, 最后输出.&lt;/p&gt;

&lt;h3 id=&#34;handlers-go&#34;&gt;handlers.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;github.com/julienschmidt/httprouter&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func CreateUser(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	io.WriteString(w, &amp;quot;Create User Handler&amp;quot;)
}

func Login(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	uname := p.ByName(&amp;quot;username&amp;quot;)
	io.WriteString(w, uname)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;apidef-go-接受用户名和密码&#34;&gt;apidef.go 接受用户名和密码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package defs

type UserCredential struct {
	Username string `json:&amp;quot;username&amp;quot;`
	Pwd string `json:&amp;quot;pwd&amp;quot;`
}

--------------------------------------------
`json`是go里打tag的一种方式,会产生下面的结构
{
	Username:xxx
	Pwd:xxx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;errs-go-错误返回&#34;&gt;errs.go 错误返回&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package defs

type Err struct {
	Error string `json:&amp;quot;error&amp;quot;`
	ErrorCode string `json:&amp;quot;error_code&amp;quot;`
}

type ErrResponse struct {
	HttpSC int
	Erros Err
}

var (
	ErrorRequestBodyParseFailed = ErrResponse{HttpSC: 400, Error:Err{Error:&amp;quot;Request body is not correct&amp;quot;, ErrorCode:&amp;quot;001&amp;quot;}}
	ErrorNotAuthUser = ErrResponse{HttpSC: 401, Error:Err{Error:&amp;quot;User authentical faild&amp;quot;, ErrorCode:&amp;quot;002&amp;quot;}}
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dpops-api-go-连接数据库并操作&#34;&gt;dpops/api.go 连接数据库并操作&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package dbops

import (
	&amp;quot;database/sql&amp;quot;
)

func openConn() *sql.DB {

}

func AddUserCredential(loginName string, pwd string) error {

}

func GetUserCredential(loginName string ) (string, error)  {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;response-go-根据处理结果返回相应的response&#34;&gt;response.go 根据处理结果返回相应的response&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	//&amp;quot;io&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func sendErrorResponse(w http.ResponseWriter){

}

func sendNormalResponse(w http.ResponseWriter)  {

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>